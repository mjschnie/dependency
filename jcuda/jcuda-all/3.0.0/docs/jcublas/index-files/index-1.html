<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_10) on Thu Mar 25 20:45:11 CET 2010 -->
<TITLE>
C-Index (JCublas API Documentation)
</TITLE>

<META NAME="date" CONTENT="2010-03-25">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="C-Index (JCublas API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../jcuda/jcublas/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../jcuda/jcublas/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Index</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV LETTER&nbsp;
&nbsp;<A HREF="index-2.html"><B>NEXT LETTER</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?index-filesindex-1.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="index-1.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<A HREF="index-1.html">C</A> <A HREF="index-2.html">I</A> <A HREF="index-3.html">J</A> <A HREF="index-4.html">P</A> <A HREF="index-5.html">S</A> <A HREF="index-6.html">T</A> <A HREF="index-7.html">X</A> <A HREF="index-8.html">Y</A> <HR>
<A NAME="_C_"><!-- --></A><H2>
<B>C</B></H2>
<DL>
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_ALLOC_FAILED"><B>CUBLAS_STATUS_ALLOC_FAILED</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Resource allocation failed
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_ARCH_MISMATCH"><B>CUBLAS_STATUS_ARCH_MISMATCH</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Function requires an architectural feature absent from the 
 architecture of the device
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_EXECUTION_FAILED"><B>CUBLAS_STATUS_EXECUTION_FAILED</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>GPU program failed to execute
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_INTERNAL_ERROR"><B>CUBLAS_STATUS_INTERNAL_ERROR</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>An internal CUBLAS operation failed
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_INVALID_VALUE"><B>CUBLAS_STATUS_INVALID_VALUE</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Unsupported numerical value was passed to function
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_MAPPING_ERROR"><B>CUBLAS_STATUS_MAPPING_ERROR</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Access to GPU memory space failed
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_NOT_INITIALIZED"><B>CUBLAS_STATUS_NOT_INITIALIZED</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Library not initialized
<DT><A HREF="../jcuda/jcublas/cublasStatus.html#CUBLAS_STATUS_SUCCESS"><B>CUBLAS_STATUS_SUCCESS</B></A> - 
Static variable in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas">cublasStatus</A>
<DD>Operation completed successfully
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasAlloc(int, int, jcuda.Pointer)"><B>cublasAlloc(int, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCaxpy(int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCaxpy(int, cuComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCaxpy (int n, cuComplex alpha, const cuComplex *x, int incx, 
              cuComplex *y, int incy)

 multiplies single-complex vector x by single-complex scalar alpha and adds 
 the result to single-complex vector y; that is, it overwrites single-complex
 y with single-complex alpha * x + y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCcopy(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCcopy(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCcopy (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 copies the single-complex vector x to the single-complex vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCgbmv(char, int, int, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCgbmv(char, int, int, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCgbmv (char trans, int m, int n, int kl, int ku, cuComplex alpha,
              const cuComplex *A, int lda, const cuComplex *x, int incx, cuComplex beta,
              cuComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCgemm(char, char, int, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCgemm(char, char, int, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasCgemm (char transa, char transb, int m, int n, int k, 
                   cuComplex alpha, const cuComplex *A, int lda, 
                   const cuComplex *B, int ldb, cuComplex beta, 
                   cuComplex *C, int ldc)

 performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are single-complex scalars, and A, B and C are matrices
 consisting of single-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCgemv(char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCgemv(char, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasCgemv (char trans, int m, int n, cuComplex alpha, const cuComplex *A, 
              int lda, const cuComplex *x, int incx, cuComplex beta, cuComplex *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCgerc(int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCgerc(int, int, cuComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasCgerc (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCgeru(int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCgeru(int, int, cuComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasCgeru (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasChbmv(char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasChbmv(char, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasChbmv (char uplo, int n, int k, cuComplex alpha, const cuComplex *A, int lda,
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasChemm(char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasChemm(char, char, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasChemm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a hermitian matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasChemv(char, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasChemv(char, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasChemv (char uplo, int n, cuComplex alpha, const cuComplex *A, int lda, 
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision complex scalars, and x and y are single 
 precision complex vectors, each with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCher(char, int, float, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCher(char, int, float, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCher (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a single precision real scalar, x is an n element single 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCher2(char, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCher2(char, int, cuComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasCher2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
                   const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, x and y are n element single 
 precision complex vector and A is an n by n hermitian matrix consisting of single 
 precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCher2k(char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasCher2k(char, char, int, int, cuComplex, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCher2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCherk(char, char, int, int, float, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasCherk(char, char, int, int, float, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCherk (char uplo, char trans, int n, int k, float alpha, 
              const cuComplex *A, int lda, float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasChpr(char, int, float, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasChpr(char, int, float, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasChpr (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a single precision real scalar and x is an n element single 
 precision complex vector.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasChpr2(char, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasChpr2(char, int, cuComplex, Pointer, int, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD> 
 void 
 cublasChpr2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
              const cuComplex *y, int incy, cuComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, and x and y are n element single 
 precision complex vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCrot(int, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.jcublas.cuComplex)"><B>cublasCrot(int, Pointer, int, Pointer, int, float, cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCrot (int n, cuComplex *x, int incx, cuComplex *y, int incy, float sc,
             cuComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCrotg(jcuda.Pointer, jcuda.jcublas.cuComplex, jcuda.Pointer, jcuda.Pointer)"><B>cublasCrotg(Pointer, cuComplex, Pointer, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCrotg (cuComplex *host_ca, cuComplex cb, float *host_sc, cuComplex *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCscal(int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCscal(int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCsrot(int, jcuda.Pointer, int, jcuda.Pointer, int, float, float)"><B>cublasCsrot(int, Pointer, int, Pointer, int, float, float)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 csrot (int n, cuComplex *x, int incx, cuCumplex *y, int incy, float c, 
        float s)

 multiplies a 2x2 rotation matrix ( c s) with a 2xn matrix ( transpose(x) )
                                  (-s c)                   ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCsscal(int, float, jcuda.Pointer, int)"><B>cublasCsscal(int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCsscal (int n, float alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCswap(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCswap(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCswap (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 interchanges the single-complex vector x with the single-complex vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCsymm(char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCsymm(char, char, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCsymm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a symmetric matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCsyr2k(char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCsyr2k(char, char, int, int, cuComplex, Pointer, int, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCsyr2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCsyrk(char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int)"><B>cublasCsyrk(char, char, int, int, cuComplex, Pointer, int, cuComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCsyrk (char uplo, char trans, int n, int k, cuComplex alpha, 
              const cuComplex *A, int lda, cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtbmv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtbmv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCtbmv (char uplo, char trans, char diag, int n, int k, const cuComplex *A,
              int lda, cuComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtbsv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtbsv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasCtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuComplex *A, int lda, cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtpmv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasCtpmv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCtpmv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtpsv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasCtpsv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCtpsv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtrmm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtrmm(char, char, char, char, int, int, cuComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuComplex alpha, const cuComplex *A, int lda, const cuComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision complex scalar, B is an m x n matrix composed
 of single precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtrmv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtrmv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 
 cublasCtrmv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtrsm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtrsm(char, char, char, char, int, int, cuComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasCtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuComplex alpha, const cuComplex *A, int lda,
              cuComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision complex scalar, and X and B are m x n matrices
 that are composed of single precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasCtrsv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasCtrsv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasCtrsv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are single precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDasum(int, jcuda.Pointer, int)"><B>cublasDasum(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 double 
 cublasDasum (int n, const double *x, int incx)

 computes the sum of the absolute values of the elements of double 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDaxpy(int, double, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDaxpy(int, double, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDaxpy (int n, double alpha, const double *x, int incx, double *y, 
              int incy)

 multiplies double-precision vector x by double-precision scalar alpha 
 and adds the result to double-precision vector y; that is, it overwrites 
 double-precision y with double-precision alpha * x + y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDcopy(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDcopy(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDcopy (int n, const double *x, int incx, double *y, int incy)

 copies the double-precision vector x to the double-precision vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDdot(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDdot(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 double 
 cublasDdot (int n, const double *x, int incx, const double *y, int incy)

 computes the dot product of two double-precision vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDgbmv(char, int, int, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDgbmv(char, int, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDgbmv (char trans, int m, int n, int kl, int ku, double alpha,
              const double *A, int lda, const double *x, int incx, double beta,
              double *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision scalars. x and y are double precision
 vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDgemm(char, char, int, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDgemm(char, char, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDgemm (char transa, char transb, int m, int n, int k, double alpha,
              const double *A, int lda, const double *B, int ldb, 
              double beta, double *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by scalar alpha, and adds the sum to the product of matrix C and
 scalar beta.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDgemv(char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDgemv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasDgemv (char trans, int m, int n, double alpha, const double *A, 
              int lda, const double *x, int incx, double beta, double *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDger(int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDger(int, int, double, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasDger (int m, int n, double alpha, const double *x, int incx,
             const double *y, int incy, double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision scalar, x is an m element double
 precision vector, y is an n element double precision vector, and A
 is an m by n matrix consisting of double precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDnrm2(int, jcuda.Pointer, int)"><B>cublasDnrm2(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 double 
 dnrm2 (int n, const double *x, int incx)

 computes the Euclidean norm of the double-precision n-vector x (with
 storage increment incx).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDrot(int, jcuda.Pointer, int, jcuda.Pointer, int, double, double)"><B>cublasDrot(int, Pointer, int, Pointer, int, double, double)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDrot (int n, double *x, int incx, double *y, int incy, double sc, 
             double ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDrotg(jcuda.Pointer, jcuda.Pointer, jcuda.Pointer, jcuda.Pointer)"><B>cublasDrotg(Pointer, Pointer, Pointer, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDrotg (double *host_sa, double *host_sb, double *host_sc, double *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDrotm(int, jcuda.Pointer, int, jcuda.Pointer, int, double[])"><B>cublasDrotm(int, Pointer, int, Pointer, int, double[])</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDrotmg(double[], double[], double[], double, double[])"><B>cublasDrotmg(double[], double[], double[], double, double[])</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsbmv(char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDsbmv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDsbmv (char uplo, int n, int k, double alpha, const double *A, int lda,
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision scalars. x and y are double precision
 vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDscal(int, double, jcuda.Pointer, int)"><B>cublasDscal(int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDscal (int n, double alpha, double *x, int incx)

 replaces double-precision vector x with double-precision alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDspmv(char, int, double, jcuda.Pointer, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDspmv(char, int, double, Pointer, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDspmv (char uplo, int n, double alpha, const double *AP, const double *x,
              int incx, double beta, double *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDspr(char, int, double, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasDspr(char, int, double, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDspr (char uplo, int n, double alpha, const double *x, int incx, 
             double *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a double precision scalar and x is an n element double 
 precision vector.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDspr2(char, int, double, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasDspr2(char, int, double, Pointer, int, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD> 
 void 
 cublasDspr2 (char uplo, int n, double alpha, const double *x, int incx, 
              const double *y, int incy, double *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, and x and y are n element double 
 precision vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDswap(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDswap(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDswap (int n, double *x, int incx, double *y, int incy)

 replaces double-precision vector x with double-precision alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsymm(char, char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDsymm(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDsymm (char side, char uplo, int m, int n, double alpha,
              const double *A, int lda, const double *B, int ldb,
              double beta, double *C, int ldc);

 performs one of the matrix-matrix operations

   C = alpha * A * B + beta * C, or
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision scalars, A is a symmetric matrix
 consisting of double precision elements and stored in either lower or upper
 storage mode, and B and C are m x n matrices consisting of double precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsymv(char, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDsymv(char, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDsymv (char uplo, int n, double alpha, const double *A, int lda, 
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors, each with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsyr(char, int, double, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDsyr(char, int, double, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDsyr (char uplo, int n, double alpha, const double *x, int incx, 
             double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a double precision scalar, x is an n element double 
 precision vector and A is an n x n symmetric matrix consisting of 
 double precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsyr2(char, int, double, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDsyr2(char, int, double, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasDsyr2 (char uplo, int n, double alpha, const double *x, int incx, 
                   const double *y, int incy, double *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, x and y are n element double 
 precision vector and A is an n by n symmetric matrix consisting of double 
 precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsyr2k(char, char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDsyr2k(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDsyr2k (char uplo, char trans, int n, int k, double alpha,
               const double *A, int lda, const double *B, int ldb,
               double beta, double *C, int ldc)

 performs one of the symmetric rank 2k operations

    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDsyrk(char, char, int, int, double, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasDsyrk(char, char, int, int, double, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDsyrk (char uplo, char trans, int n, int k, double alpha, 
              const double *A, int lda, double beta, double *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtbmv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtbmv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtbmv (char uplo, char trans, char diag, int n, int k, const double *A,
              int lda, double *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n-element double precision vector, and A is
 an n x n, unit or non-unit, upper or lower triangular band matrix composed
 of double precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtbsv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtbsv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasDtbsv (char uplo, char trans, char diag, int n, int k,
                   const double *A, int lda, double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtpmv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasDtpmv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtpmv (char uplo, char trans, char diag, int n, const double *AP, 
              double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element double precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of double precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtpsv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasDtpsv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtpsv (char uplo, char trans, char diag, int n, const double *AP, 
              double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtrmm(char, char, char, char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtrmm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              double alpha, const double *A, int lda, const double *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision scalar, B is an m x n matrix composed
 of double precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtrmv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtrmv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtrmv (char uplo, char trans, char diag, int n, const double *A,
              int lda, double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtrsm(char, char, char, char, int, int, double, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtrsm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasDtrsm (char side, char uplo, char transa, char diag, int m, int n,
              double alpha, const double *A, int lda, double *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision scalar, and X and B are m x n matrices
 that are composed of double precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDtrsv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasDtrsv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasDtrsv (char uplo, char trans, char diag, int n, const double *A, 
              int lda, double *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are double precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDzasum(int, jcuda.Pointer, int)"><B>cublasDzasum(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 double 
 cublasDzasum (int n, const cuDoubleComplex *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 double precision result.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasDznrm2(int, jcuda.Pointer, int)"><B>cublasDznrm2(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 double 
 cublasDznrm2 (int n, const cuDoubleComplex *x, int incx)

 computes the Euclidean norm of the double precision complex n-vector x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasFree(jcuda.Pointer)"><B>cublasFree(Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetError()"><B>cublasGetError()</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, jcuda.Pointer, int, jcuda.jcublas.cuComplex[], int, int)"><B>cublasGetMatrix(int, int, Pointer, int, cuComplex[], int, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)"><B>cublasGetMatrix(int, int, Pointer, int, cuDoubleComplex[], int, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuDoubleComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetVector(int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasGetVector(int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetVector(int, jcuda.Pointer, int, jcuda.jcublas.cuComplex[], int, int)"><B>cublasGetVector(int, Pointer, int, cuComplex[], int, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasGetVector(int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)"><B>cublasGetVector(int, Pointer, int, cuDoubleComplex[], int, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuDoubleComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIcamax(int, jcuda.Pointer, int)"><B>cublasIcamax(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIcamax (int n, const float *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIcamin(int, jcuda.Pointer, int)"><B>cublasIcamin(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIcamin (int n, const float *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIdamax(int, jcuda.Pointer, int)"><B>cublasIdamax(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 idamax (int n, const double *x, int incx)

 finds the smallest index of the maximum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIdamin(int, jcuda.Pointer, int)"><B>cublasIdamin(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 idamin (int n, const double *x, int incx)

 finds the smallest index of the minimum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasInit()"><B>cublasInit()</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIsamax(int, jcuda.Pointer, int)"><B>cublasIsamax(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIsamax (int n, const float *x, int incx)

 finds the smallest index of the maximum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIsamin(int, jcuda.Pointer, int)"><B>cublasIsamin(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIsamin (int n, const float *x, int incx)

 finds the smallest index of the minimum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIzamax(int, jcuda.Pointer, int)"><B>cublasIzamax(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIzamax (int n, const double *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasIzamin(int, jcuda.Pointer, int)"><B>cublasIzamin(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 int 
 cublasIzamin (int n, const cuDoubleComplex *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSasum(int, jcuda.Pointer, int)"><B>cublasSasum(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 float 
 cublasSasum (int n, const float *x, int incx)

 computes the sum of the absolute values of the elements of single 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSaxpy(int, float, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSaxpy(int, float, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasSaxpy (int n, float alpha, const float *x, int incx, float *y, 
              int incy)

 multiplies single precision vector x by single precision scalar alpha 
 and adds the result to single precision vector y; that is, it overwrites 
 single precision y with single precision alpha * x + y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasScasum(int, jcuda.Pointer, int)"><B>cublasScasum(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 float 
 cublasScasum (int n, const cuDouble *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 single precision result.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasScnrm2(int, jcuda.Pointer, int)"><B>cublasScnrm2(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 float 
 cublasScnrm2 (int n, const cuComplex *x, int incx)

 computes the Euclidean norm of the single-complex n-vector x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasScopy(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasScopy(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasScopy (int n, const float *x, int incx, float *y, int incy)

 copies the single precision vector x to the single precision vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSdot(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSdot(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 float 
 cublasSdot (int n, const float *x, int incx, const float *y, int incy)

 computes the dot product of two single precision vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, jcuda.jcublas.cuComplex[], int, int, jcuda.Pointer, int)"><B>cublasSetMatrix(int, int, cuComplex[], int, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, jcuda.jcublas.cuDoubleComplex[], int, int, jcuda.Pointer, int)"><B>cublasSetMatrix(int, int, cuDoubleComplex[], int, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuDoubleComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetVector(int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSetVector(int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetVector(int, jcuda.jcublas.cuComplex[], int, int, jcuda.Pointer, int)"><B>cublasSetVector(int, cuComplex[], int, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSetVector(int, jcuda.jcublas.cuDoubleComplex[], int, int, jcuda.Pointer, int)"><B>cublasSetVector(int, cuDoubleComplex[], int, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Extended wrapper for arrays of cuDoubleComplex values.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSgbmv(char, int, int, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSgbmv(char, int, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSgbmv (char trans, int m, int n, int kl, int ku, float alpha,
              const float *A, int lda, const float *x, int incx, float beta,
              float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision scalars. x and y are single precision
 vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSgemm(char, char, int, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSgemm(char, char, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSgemm (char transa, char transb, int m, int n, int k, float alpha, 
              const float *A, int lda, const float *B, int ldb, float beta, 
              float *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by a scalar alpha, and adds the sum to the product of matrix C and
 scalar beta. sgemm() performs one of the matrix-matrix operations:

     C = alpha * op(A) * op(B) + beta * C,

 where op(X) is one of

     op(X) = X   or   op(X) = transpose(X)

 alpha and beta are single precision scalars, and A, B and C are 
 matrices consisting of single precision elements, with op(A) an m x k 
 matrix, op(B) a k x n matrix, and C an m x n matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSgemv(char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSgemv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasSgemv (char trans, int m, int n, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSger(int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSger(int, int, float, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasSger (int m, int n, float alpha, const float *x, int incx, 
             const float *y, int incy, float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision scalar, x is an m element single 
 precision vector, y is an n element single precision vector, and A 
 is an m by n matrix consisting of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasShutdown()"><B>cublasShutdown()</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSnrm2(int, jcuda.Pointer, int)"><B>cublasSnrm2(int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 float 
 cublasSnrm2 (int n, const float *x, int incx)

 computes the Euclidean norm of the single precision n-vector x (with
 storage increment incx).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSrot(int, jcuda.Pointer, int, jcuda.Pointer, int, float, float)"><B>cublasSrot(int, Pointer, int, Pointer, int, float, float)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSrot (int n, float *x, int incx, float *y, int incy, float sc, 
             float ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSrotg(jcuda.Pointer, jcuda.Pointer, jcuda.Pointer, jcuda.Pointer)"><B>cublasSrotg(Pointer, Pointer, Pointer, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSrotg (float *host_sa, float *host_sb, float *host_sc, float *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSrotm(int, jcuda.Pointer, int, jcuda.Pointer, int, float[])"><B>cublasSrotm(int, Pointer, int, Pointer, int, float[])</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSrotmg(float[], float[], float[], float, float[])"><B>cublasSrotmg(float[], float[], float[], float, float[])</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>Wrapper for CUBLAS function.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsbmv(char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSsbmv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsbmv (char uplo, int n, int k, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision scalars. x and y are single precision
 vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSscal(int, float, jcuda.Pointer, int)"><B>cublasSscal(int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 sscal (int n, float alpha, float *x, int incx)

 replaces single precision vector x with single precision alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSspmv(char, int, float, jcuda.Pointer, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSspmv(char, int, float, Pointer, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSspmv (char uplo, int n, float alpha, const float *AP, const float *x,
              int incx, float beta, float *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSspr(char, int, float, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasSspr(char, int, float, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSspr (char uplo, int n, float alpha, const float *x, int incx, 
             float *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a single precision scalar and x is an n element single 
 precision vector.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSspr2(char, int, float, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasSspr2(char, int, float, Pointer, int, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD> 
 void 
 cublasSspr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, and x and y are n element single 
 precision vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSswap(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSswap(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasSswap (int n, float *x, int incx, float *y, int incy)

 replaces single precision vector x with single precision alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsymm(char, char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSsymm(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsymm (char side, char uplo, int m, int n, float alpha, 
              const float *A, int lda, const float *B, int ldb, 
              float beta, float *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision scalars, A is a symmetric matrix
 consisting of single precision elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsymv(char, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSsymv(char, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsymv (char uplo, int n, float alpha, const float *A, int lda, 
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors, each with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsyr(char, int, float, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSsyr(char, int, float, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsyr (char uplo, int n, float alpha, const float *x, int incx,
             float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a single precision scalar, x is an n element single 
 precision vector and A is an n x n symmetric matrix consisting of 
 single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsyr2(char, int, float, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasSsyr2(char, int, float, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsyr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, x and y are n element single 
 precision vector and A is an n by n symmetric matrix consisting of single 
 precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsyr2k(char, char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSsyr2k(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsyr2k (char uplo, char trans, int n, int k, float alpha, 
               const float *A, int lda, const float *B, int ldb, 
               float beta, float *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasSsyrk(char, char, int, int, float, jcuda.Pointer, int, float, jcuda.Pointer, int)"><B>cublasSsyrk(char, char, int, int, float, Pointer, int, float, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasSsyrk (char uplo, char trans, int n, int k, float alpha, 
              const float *A, int lda, float beta, float *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/cublasStatus.html" title="class in jcuda.jcublas"><B>cublasStatus</B></A> - Class in <A HREF="../jcuda/jcublas/package-summary.html">jcuda.jcublas</A><DD>JCublas status return values.<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStbmv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStbmv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStbmv (char uplo, char trans, char diag, int n, int k, const float *A,
              int lda, float *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A
 or op(A) = transpose(A). x is an n-element single precision vector, and A is
 an n x n, unit or non-unit upper or lower triangular band matrix consisting
 of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStbsv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStbsv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasStbsv (char uplo, char trans, char diag, int n, int k,
                   const float *A, int lda, float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n-element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStpmv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasStpmv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStpmv (char uplo, char trans, char diag, int n, const float *AP, 
              float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element single precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStpsv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasStpsv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStpsv (char uplo, char trans, char diag, int n, const float *AP,
              float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStrmm(char, char, char, char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStrmm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStrmm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, const float *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision scalar, B is an m x n matrix composed
 of single precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStrmv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStrmv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStrmv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStrsm(char, char, char, char, int, int, float, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStrsm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStrsm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, float *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision scalar, and X and B are m x n matrices 
 that are composed of single precision elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasStrsv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasStrsv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasStrsv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are single precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZaxpy(int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZaxpy(int, cuDoubleComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZaxpy (int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              cuDoubleComplex *y, int incy)

 multiplies double-complex vector x by double-complex scalar alpha and adds 
 the result to double-complex vector y; that is, it overwrites double-complex
 y with double-complex alpha * x + y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZcopy(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZcopy(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZcopy (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 copies the double-complex vector x to the double-complex vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZdrot(int, jcuda.Pointer, int, jcuda.Pointer, int, double, double)"><B>cublasZdrot(int, Pointer, int, Pointer, int, double, double)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 zdrot (int n, cuDoubleComplex *x, int incx, cuCumplex *y, int incy, double c, 
        double s)

 multiplies a 2x2 matrix ( c s) with the 2xn matrix ( transpose(x) )
                         (-s c)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZdscal(int, double, jcuda.Pointer, int)"><B>cublasZdscal(int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZdscal (int n, double alpha, cuDoubleComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZgbmv(char, int, int, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZgbmv(char, int, int, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZgbmv (char trans, int m, int n, int kl, int ku, cuDoubleComplex alpha,
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, cuDoubleComplex beta,
              cuDoubleComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZgemm(char, char, int, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZgemm(char, char, int, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasZgemm (char transa, char transb, int m, int n, int k,
                   cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
                   const cuDoubleComplex *B, int ldb, cuDoubleComplex beta,
                   cuDoubleComplex *C, int ldc)

 zgemm performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are double-complex scalars, and A, B and C are matrices
 consisting of double-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZgemv(char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZgemv(char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasZgemv (char trans, int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZgerc(int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZgerc(int, int, cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasZgerc (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZgeru(int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZgeru(int, int, cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasZgeru (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhbmv(char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZhbmv(char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZhbmv (char uplo, int n, int k, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhemm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZhemm(char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZhemm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a hermitian matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhemv(char, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZhemv(char, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZhemv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, 
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors, each with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZher(char, int, double, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZher(char, int, double, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZher (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a double precision real scalar, x is an n element double 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZher2(char, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZher2(char, int, cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasZher2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
                   const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, x and y are n element double 
 precision complex vector and A is an n by n hermitian matrix consisting of double 
 precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZher2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasZher2k(char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZher2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZherk(char, char, int, int, double, jcuda.Pointer, int, double, jcuda.Pointer, int)"><B>cublasZherk(char, char, int, int, double, Pointer, int, double, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZherk (char uplo, char trans, int n, int k, double alpha, 
              const cuDoubleComplex *A, int lda, double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhpmv(char, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZhpmv(char, int, cuDoubleComplex, Pointer, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZhpmv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *AP, const cuDoubleComplex *x,
              int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors with n elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhpr(char, int, double, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasZhpr(char, int, double, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZhpr (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a double precision real scalar and x is an n element double 
 precision complex vector.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZhpr2(char, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.Pointer)"><B>cublasZhpr2(char, int, cuDoubleComplex, Pointer, int, Pointer, int, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD> 
 void 
 cublasZhpr2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              const cuDoubleComplex *y, int incy, cuDoubleComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, and x and y are n element double 
 precision complex vectors.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZrot(int, jcuda.Pointer, int, jcuda.Pointer, int, double, jcuda.jcublas.cuDoubleComplex)"><B>cublasZrot(int, Pointer, int, Pointer, int, double, cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 cublasZrot (int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy, double sc,
             cuDoubleComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZrotg(jcuda.Pointer, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, jcuda.Pointer)"><B>cublasZrotg(Pointer, cuDoubleComplex, Pointer, Pointer)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZrotg (cuDoubleComplex *host_ca, cuDoubleComplex cb, double *host_sc, double *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZscal(int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZscal(int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZswap(int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZswap(int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZswap (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 interchanges the double-complex vector x with the double-complex vector y.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZsymm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZsymm(char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZsymm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a symmetric matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZsyr2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZsyr2k(char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZsyr2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZsyrk(char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int)"><B>cublasZsyrk(char, char, int, int, cuDoubleComplex, Pointer, int, cuDoubleComplex, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZsyrk (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtbmv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtbmv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtbmv (char uplo, char trans, char diag, int n, int k, const cuDoubleComplex *A,
              int lda, cuDoubleComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtbsv(char, char, char, int, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtbsv(char, char, char, int, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void cublasZtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuDoubleComplex *A, int lda, cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtpmv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasZtpmv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtpmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtpsv(char, char, char, int, jcuda.Pointer, jcuda.Pointer, int)"><B>cublasZtpsv(char, char, char, int, Pointer, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtpsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtrmm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtrmm(char, char, char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision complex scalar, B is an m x n matrix composed
 of double precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtrmv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtrmv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtrmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtrsm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtrsm(char, char, char, char, int, int, cuDoubleComplex, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void
 cublasZtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              cuDoubleComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision complex scalar, and X and B are m x n matrices
 that are composed of double precision complex elements.
<DT><A HREF="../jcuda/jcublas/JCublas.html#cublasZtrsv(char, char, char, int, jcuda.Pointer, int, jcuda.Pointer, int)"><B>cublasZtrsv(char, char, char, int, Pointer, int, Pointer, int)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/JCublas.html" title="class in jcuda.jcublas">JCublas</A>
<DD>
 void 
 cublasZtrsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are double precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCabs(jcuda.jcublas.cuComplex)"><B>cuCabs(cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the absolute value of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCabs(jcuda.jcublas.cuDoubleComplex)"><B>cuCabs(cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the absolute value of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCadd(jcuda.jcublas.cuComplex, jcuda.jcublas.cuComplex)"><B>cuCadd(cuComplex, cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns a new complex number that is the sum of the given
 complex numbers.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCadd(jcuda.jcublas.cuDoubleComplex, jcuda.jcublas.cuDoubleComplex)"><B>cuCadd(cuDoubleComplex, cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns a new complex number that is the sum of the given
 complex numbers.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCdiv(jcuda.jcublas.cuComplex, jcuda.jcublas.cuComplex)"><B>cuCdiv(cuComplex, cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the quotient of the given complex numbers.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCdiv(jcuda.jcublas.cuDoubleComplex, jcuda.jcublas.cuDoubleComplex)"><B>cuCdiv(cuDoubleComplex, cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the quotient of the given complex numbers.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCimag(jcuda.jcublas.cuComplex)"><B>cuCimag(cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the imaginary part of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCimag(jcuda.jcublas.cuDoubleComplex)"><B>cuCimag(cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the imaginary part of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCmplx(float, float)"><B>cuCmplx(float, float)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Creates a new complex number consisting of the given real and
 imaginary part.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCmplx(double, double)"><B>cuCmplx(double, double)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Creates a new complex number consisting of the given real and
 imaginary part.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCmul(jcuda.jcublas.cuComplex, jcuda.jcublas.cuComplex)"><B>cuCmul(cuComplex, cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the product of the given complex numbers.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCmul(jcuda.jcublas.cuDoubleComplex, jcuda.jcublas.cuDoubleComplex)"><B>cuCmul(cuDoubleComplex, cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the product of the given complex numbers.
<DT><A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas"><B>cuComplex</B></A> - Class in <A HREF="../jcuda/jcublas/package-summary.html">jcuda.jcublas</A><DD>Java port of the CUBLAS complex number structure.<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuConj(jcuda.jcublas.cuComplex)"><B>cuConj(cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the complex conjugate of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuConj(jcuda.jcublas.cuDoubleComplex)"><B>cuConj(cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the complex conjugate of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuComplex.html#cuCreal(jcuda.jcublas.cuComplex)"><B>cuCreal(cuComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>
<DD>Returns the real part of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html#cuCreal(jcuda.jcublas.cuDoubleComplex)"><B>cuCreal(cuDoubleComplex)</B></A> - 
Static method in class jcuda.jcublas.<A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>
<DD>Returns the real part of the given complex number.
<DT><A HREF="../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas"><B>cuDoubleComplex</B></A> - Class in <A HREF="../jcuda/jcublas/package-summary.html">jcuda.jcublas</A><DD>Java port of the CUBLAS complex number structure for double 
 precision numbers</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../jcuda/jcublas/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../jcuda/jcublas/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Index</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV LETTER&nbsp;
&nbsp;<A HREF="index-2.html"><B>NEXT LETTER</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?index-filesindex-1.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="index-1.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<A HREF="index-1.html">C</A> <A HREF="index-2.html">I</A> <A HREF="index-3.html">J</A> <A HREF="index-4.html">P</A> <A HREF="index-5.html">S</A> <A HREF="index-6.html">T</A> <A HREF="index-7.html">X</A> <A HREF="index-8.html">Y</A> <HR>

</BODY>
</HTML>
