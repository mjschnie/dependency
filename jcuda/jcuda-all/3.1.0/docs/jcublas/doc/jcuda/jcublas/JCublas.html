<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_04) on Sun Jul 11 20:16:56 CEST 2010 -->
<TITLE>
JCublas (JCublas API Documentation)
</TITLE>

<META NAME="date" CONTENT="2010-07-11">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JCublas (JCublas API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../jcuda/jcublas/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCublas.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/jcublas/JCublas.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCublas.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jcuda.jcublas</FONT>
<BR>
Class JCublas</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>jcuda.jcublas.JCublas</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>JCublas</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Java bindings for CUBLAS, the NVIDIA CUDA BLAS library.
 <br />
 Most comments are taken from the cublas.h header file.
 <br />
<P>

<P>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasAlloc(int, int, Pointer)">cublasAlloc</A></B>(int&nbsp;n,
            int&nbsp;elemSize,
            Pointer&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCaxpy(int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)">cublasCaxpy</A></B>(int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCaxpy (int n, cuComplex alpha, const cuComplex *x, int incx, 
              cuComplex *y, int incy)

 multiplies single-complex vector x by single-complex scalar alpha and adds 
 the result to single-complex vector y; that is, it overwrites single-complex
 y with single-complex alpha * x + y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCcopy(int, Pointer, int, Pointer, int)">cublasCcopy</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCcopy (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 copies the single-complex vector x to the single-complex vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCgbmv(char, int, int, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCgbmv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;kl,
            int&nbsp;ku,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCgbmv (char trans, int m, int n, int kl, int ku, cuComplex alpha,
              const cuComplex *A, int lda, const cuComplex *x, int incx, cuComplex beta,
              cuComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCgemm(char, char, int, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCgemm</A></B>(char&nbsp;transa,
            char&nbsp;transb,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasCgemm (char transa, char transb, int m, int n, int k, 
                   cuComplex alpha, const cuComplex *A, int lda, 
                   const cuComplex *B, int ldb, cuComplex beta, 
                   cuComplex *C, int ldc)

 performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are single-complex scalars, and A, B and C are matrices
 consisting of single-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCgemv(char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCgemv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasCgemv (char trans, int m, int n, cuComplex alpha, const cuComplex *A, 
              int lda, const cuComplex *x, int incx, cuComplex beta, cuComplex *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCgerc(int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)">cublasCgerc</A></B>(int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasCgerc (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCgeru(int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)">cublasCgeru</A></B>(int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasCgeru (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasChbmv(char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasChbmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasChbmv (char uplo, int n, int k, cuComplex alpha, const cuComplex *A, int lda,
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasChemm(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasChemm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasChemm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a hermitian matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasChemv(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasChemv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasChemv (char uplo, int n, cuComplex alpha, const cuComplex *A, int lda, 
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision complex scalars, and x and y are single 
 precision complex vectors, each with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCher(char, int, float, Pointer, int, Pointer, int)">cublasCher</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           float&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCher (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a single precision real scalar, x is an n element single 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCher2(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)">cublasCher2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasCher2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
                   const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, x and y are n element single 
 precision complex vector and A is an n by n hermitian matrix consisting of single 
 precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCher2k(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, float, Pointer, int)">cublasCher2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             float&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCher2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCherk(char, char, int, int, float, Pointer, int, float, Pointer, int)">cublasCherk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            float&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCherk (char uplo, char trans, int n, int k, float alpha, 
              const cuComplex *A, int lda, float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasChpr(char, int, float, Pointer, int, Pointer)">cublasChpr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           float&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasChpr (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a single precision real scalar and x is an n element single 
 precision complex vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasChpr2(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer)">cublasChpr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 void 
 cublasChpr2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
              const cuComplex *y, int incy, cuComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, and x and y are n element single 
 precision complex vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCrot(int, Pointer, int, Pointer, int, float, jcuda.jcublas.cuComplex)">cublasCrot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           float&nbsp;c,
           <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCrot (int n, cuComplex *x, int incx, cuComplex *y, int incy, float sc,
             cuComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCrotg(Pointer, jcuda.jcublas.cuComplex, Pointer, Pointer)">cublasCrotg</A></B>(Pointer&nbsp;host_ca,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;cb,
            Pointer&nbsp;host_sc,
            Pointer&nbsp;host_cs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCrotg (cuComplex *host_ca, cuComplex cb, float *host_sc, cuComplex *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCscal(int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCscal</A></B>(int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCsrot(int, Pointer, int, Pointer, int, float, float)">cublasCsrot</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            float&nbsp;c,
            float&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 csrot (int n, cuComplex *x, int incx, cuCumplex *y, int incy, float c, 
        float s)

 multiplies a 2x2 rotation matrix ( c s) with a 2xn matrix ( transpose(x) )
                                  (-s c)                   ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCsscal(int, float, Pointer, int)">cublasCsscal</A></B>(int&nbsp;n,
             float&nbsp;alpha,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCsscal (int n, float alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCswap(int, Pointer, int, Pointer, int)">cublasCswap</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCswap (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 interchanges the single-complex vector x with the single-complex vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCsymm(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCsymm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCsymm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a symmetric matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCsyr2k(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCsyr2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCsyr2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCsyrk(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)">cublasCsyrk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCsyrk (char uplo, char trans, int n, int k, cuComplex alpha, 
              const cuComplex *A, int lda, cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtbmv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasCtbmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCtbmv (char uplo, char trans, char diag, int n, int k, const cuComplex *A,
              int lda, cuComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtbsv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasCtbsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasCtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuComplex *A, int lda, cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtpmv(char, char, char, int, Pointer, Pointer, int)">cublasCtpmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCtpmv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtpsv(char, char, char, int, Pointer, Pointer, int)">cublasCtpsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCtpsv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtrmm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)">cublasCtrmm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuComplex alpha, const cuComplex *A, int lda, const cuComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision complex scalar, B is an m x n matrix composed
 of single precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtrmv(char, char, char, int, Pointer, int, Pointer, int)">cublasCtrmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 
 cublasCtrmv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtrsm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)">cublasCtrsm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasCtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuComplex alpha, const cuComplex *A, int lda,
              cuComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision complex scalar, and X and B are m x n matrices
 that are composed of single precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasCtrsv(char, char, char, int, Pointer, int, Pointer, int)">cublasCtrsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasCtrsv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are single precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDasum(int, Pointer, int)">cublasDasum</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 double 
 cublasDasum (int n, const double *x, int incx)

 computes the sum of the absolute values of the elements of double 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDaxpy(int, double, Pointer, int, Pointer, int)">cublasDaxpy</A></B>(int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDaxpy (int n, double alpha, const double *x, int incx, double *y, 
              int incy)

 multiplies double-precision vector x by double-precision scalar alpha 
 and adds the result to double-precision vector y; that is, it overwrites 
 double-precision y with double-precision alpha * x + y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDcopy(int, Pointer, int, Pointer, int)">cublasDcopy</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDcopy (int n, const double *x, int incx, double *y, int incy)

 copies the double-precision vector x to the double-precision vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDdot(int, Pointer, int, Pointer, int)">cublasDdot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 double 
 cublasDdot (int n, const double *x, int incx, const double *y, int incy)

 computes the dot product of two double-precision vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDgbmv(char, int, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDgbmv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;kl,
            int&nbsp;ku,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            double&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDgbmv (char trans, int m, int n, int kl, int ku, double alpha,
              const double *A, int lda, const double *x, int incx, double beta,
              double *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision scalars. x and y are double precision
 vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDgemm(char, char, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDgemm</A></B>(char&nbsp;transa,
            char&nbsp;transb,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;k,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            double&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDgemm (char transa, char transb, int m, int n, int k, double alpha,
              const double *A, int lda, const double *B, int ldb, 
              double beta, double *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by scalar alpha, and adds the sum to the product of matrix C and
 scalar beta.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDgemv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDgemv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            double&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasDgemv (char trans, int m, int n, double alpha, const double *A, 
              int lda, const double *x, int incx, double beta, double *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDger(int, int, double, Pointer, int, Pointer, int, Pointer, int)">cublasDger</A></B>(int&nbsp;m,
           int&nbsp;n,
           double&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasDger (int m, int n, double alpha, const double *x, int incx,
             const double *y, int incy, double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision scalar, x is an m element double
 precision vector, y is an n element double precision vector, and A
 is an m by n matrix consisting of double precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDnrm2(int, Pointer, int)">cublasDnrm2</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 double 
 dnrm2 (int n, const double *x, int incx)

 computes the Euclidean norm of the double-precision n-vector x (with
 storage increment incx).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDrot(int, Pointer, int, Pointer, int, double, double)">cublasDrot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           double&nbsp;sc,
           double&nbsp;ss)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDrot (int n, double *x, int incx, double *y, int incy, double sc, 
             double ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDrotg(Pointer, Pointer, Pointer, Pointer)">cublasDrotg</A></B>(Pointer&nbsp;host_sa,
            Pointer&nbsp;host_sb,
            Pointer&nbsp;host_sc,
            Pointer&nbsp;host_ss)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDrotg (double *host_sa, double *host_sb, double *host_sc, double *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDrotm(int, Pointer, int, Pointer, int, double[])">cublasDrotm</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            double[]&nbsp;sparam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDrotmg(double[], double[], double[], double, double[])">cublasDrotmg</A></B>(double[]&nbsp;sd1,
             double[]&nbsp;sd2,
             double[]&nbsp;sx1,
             double&nbsp;sy1,
             double[]&nbsp;sparam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsbmv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDsbmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            int&nbsp;k,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            double&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDsbmv (char uplo, int n, int k, double alpha, const double *A, int lda,
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision scalars. x and y are double precision
 vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDscal(int, double, Pointer, int)">cublasDscal</A></B>(int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDscal (int n, double alpha, double *x, int incx)

 replaces double-precision vector x with double-precision alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDspmv(char, int, double, Pointer, Pointer, int, double, Pointer, int)">cublasDspmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx,
            double&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDspmv (char uplo, int n, double alpha, const double *AP, const double *x,
              int incx, double beta, double *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDspr(char, int, double, Pointer, int, Pointer)">cublasDspr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           double&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDspr (char uplo, int n, double alpha, const double *x, int incx, 
             double *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a double precision scalar and x is an n element double 
 precision vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDspr2(char, int, double, Pointer, int, Pointer, int, Pointer)">cublasDspr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 void 
 cublasDspr2 (char uplo, int n, double alpha, const double *x, int incx, 
              const double *y, int incy, double *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, and x and y are n element double 
 precision vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDswap(int, Pointer, int, Pointer, int)">cublasDswap</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDswap (int n, double *x, int incx, double *y, int incy)

 replaces double-precision vector x with double-precision alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsymm(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDsymm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            double&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDsymm (char side, char uplo, int m, int n, double alpha,
              const double *A, int lda, const double *B, int ldb,
              double beta, double *C, int ldc);

 performs one of the matrix-matrix operations

   C = alpha * A * B + beta * C, or
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision scalars, A is a symmetric matrix
 consisting of double precision elements and stored in either lower or upper
 storage mode, and B and C are m x n matrices consisting of double precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsymv(char, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDsymv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            double&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDsymv (char uplo, int n, double alpha, const double *A, int lda, 
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors, each with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsyr(char, int, double, Pointer, int, Pointer, int)">cublasDsyr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           double&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDsyr (char uplo, int n, double alpha, const double *x, int incx, 
             double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a double precision scalar, x is an n element double 
 precision vector and A is an n x n symmetric matrix consisting of 
 double precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsyr2(char, int, double, Pointer, int, Pointer, int, Pointer, int)">cublasDsyr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasDsyr2 (char uplo, int n, double alpha, const double *x, int incx, 
                   const double *y, int incy, double *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, x and y are n element double 
 precision vector and A is an n by n symmetric matrix consisting of double 
 precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsyr2k(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)">cublasDsyr2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             double&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             double&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDsyr2k (char uplo, char trans, int n, int k, double alpha,
               const double *A, int lda, const double *B, int ldb,
               double beta, double *C, int ldc)

 performs one of the symmetric rank 2k operations

    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDsyrk(char, char, int, int, double, Pointer, int, double, Pointer, int)">cublasDsyrk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            double&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDsyrk (char uplo, char trans, int n, int k, double alpha, 
              const double *A, int lda, double beta, double *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtbmv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasDtbmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtbmv (char uplo, char trans, char diag, int n, int k, const double *A,
              int lda, double *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n-element double precision vector, and A is
 an n x n, unit or non-unit, upper or lower triangular band matrix composed
 of double precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtbsv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasDtbsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasDtbsv (char uplo, char trans, char diag, int n, int k,
                   const double *A, int lda, double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtpmv(char, char, char, int, Pointer, Pointer, int)">cublasDtpmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtpmv (char uplo, char trans, char diag, int n, const double *AP, 
              double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element double precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of double precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtpsv(char, char, char, int, Pointer, Pointer, int)">cublasDtpsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtpsv (char uplo, char trans, char diag, int n, const double *AP, 
              double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtrmm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)">cublasDtrmm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              double alpha, const double *A, int lda, const double *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision scalar, B is an m x n matrix composed
 of double precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtrmv(char, char, char, int, Pointer, int, Pointer, int)">cublasDtrmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtrmv (char uplo, char trans, char diag, int n, const double *A,
              int lda, double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtrsm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)">cublasDtrsm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasDtrsm (char side, char uplo, char transa, char diag, int m, int n,
              double alpha, const double *A, int lda, double *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision scalar, and X and B are m x n matrices
 that are composed of double precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDtrsv(char, char, char, int, Pointer, int, Pointer, int)">cublasDtrsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasDtrsv (char uplo, char trans, char diag, int n, const double *A, 
              int lda, double *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are double precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDzasum(int, Pointer, int)">cublasDzasum</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 double 
 cublasDzasum (int n, const cuDoubleComplex *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 double precision result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasDznrm2(int, Pointer, int)">cublasDznrm2</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 double 
 cublasDznrm2 (int n, const cuDoubleComplex *x, int incx)

 computes the Euclidean norm of the double precision complex n-vector x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasFree(Pointer)">cublasFree</A></B>(Pointer&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetError()">cublasGetError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)">cublasGetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                int&nbsp;elemSize,
                Pointer&nbsp;A,
                int&nbsp;lda,
                Pointer&nbsp;B,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, Pointer, int, jcuda.jcublas.cuComplex[], int, int)">cublasGetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                Pointer&nbsp;A,
                int&nbsp;lda,
                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;B,
                int&nbsp;offsetB,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)">cublasGetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                Pointer&nbsp;A,
                int&nbsp;lda,
                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;B,
                int&nbsp;offsetB,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuDoubleComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrixAsync(int, int, int, Pointer, int, Pointer, int, cudaStream_t)">cublasGetMatrixAsync</A></B>(int&nbsp;rows,
                     int&nbsp;cols,
                     int&nbsp;elemSize,
                     Pointer&nbsp;A,
                     int&nbsp;lda,
                     Pointer&nbsp;B,
                     int&nbsp;ldb,
                     cudaStream_t&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVector(int, int, Pointer, int, Pointer, int)">cublasGetVector</A></B>(int&nbsp;n,
                int&nbsp;elemSize,
                Pointer&nbsp;x,
                int&nbsp;incx,
                Pointer&nbsp;y,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVector(int, Pointer, int, jcuda.jcublas.cuComplex[], int, int)">cublasGetVector</A></B>(int&nbsp;n,
                Pointer&nbsp;x,
                int&nbsp;incx,
                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;y,
                int&nbsp;offsety,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVector(int, Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)">cublasGetVector</A></B>(int&nbsp;n,
                Pointer&nbsp;x,
                int&nbsp;incx,
                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;y,
                int&nbsp;offsety,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuDoubleComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVectorAsync(int, int, Pointer, int, Pointer, int, cudaStream_t)">cublasGetVectorAsync</A></B>(int&nbsp;n,
                     int&nbsp;elemSize,
                     Pointer&nbsp;devicePtr,
                     int&nbsp;incx,
                     Pointer&nbsp;hostPtr,
                     int&nbsp;incy,
                     cudaStream_t&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIcamax(int, Pointer, int)">cublasIcamax</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIcamax (int n, const float *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIcamin(int, Pointer, int)">cublasIcamin</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIcamin (int n, const float *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIdamax(int, Pointer, int)">cublasIdamax</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 idamax (int n, const double *x, int incx)

 finds the smallest index of the maximum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIdamin(int, Pointer, int)">cublasIdamin</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 idamin (int n, const double *x, int incx)

 finds the smallest index of the minimum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasInit()">cublasInit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIsamax(int, Pointer, int)">cublasIsamax</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIsamax (int n, const float *x, int incx)

 finds the smallest index of the maximum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIsamin(int, Pointer, int)">cublasIsamin</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIsamin (int n, const float *x, int incx)

 finds the smallest index of the minimum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIzamax(int, Pointer, int)">cublasIzamax</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIzamax (int n, const double *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasIzamin(int, Pointer, int)">cublasIzamin</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int 
 cublasIzamin (int n, const cuDoubleComplex *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSasum(int, Pointer, int)">cublasSasum</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 float 
 cublasSasum (int n, const float *x, int incx)

 computes the sum of the absolute values of the elements of single 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSaxpy(int, float, Pointer, int, Pointer, int)">cublasSaxpy</A></B>(int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasSaxpy (int n, float alpha, const float *x, int incx, float *y, 
              int incy)

 multiplies single precision vector x by single precision scalar alpha 
 and adds the result to single precision vector y; that is, it overwrites 
 single precision y with single precision alpha * x + y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasScasum(int, Pointer, int)">cublasScasum</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 float 
 cublasScasum (int n, const cuDouble *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 single precision result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasScnrm2(int, Pointer, int)">cublasScnrm2</A></B>(int&nbsp;n,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 float 
 cublasScnrm2 (int n, const cuComplex *x, int incx)

 computes the Euclidean norm of the single-complex n-vector x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasScopy(int, Pointer, int, Pointer, int)">cublasScopy</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasScopy (int n, const float *x, int incx, float *y, int incy)

 copies the single precision vector x to the single precision vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSdot(int, Pointer, int, Pointer, int)">cublasSdot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 float 
 cublasSdot (int n, const float *x, int incx, const float *y, int incy)

 computes the dot product of two single precision vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetKernelStream(cudaStream_t)">cublasSetKernelStream</A></B>(cudaStream_t&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, jcuda.jcublas.cuComplex[], int, int, Pointer, int)">cublasSetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;A,
                int&nbsp;offsetA,
                int&nbsp;lda,
                Pointer&nbsp;B,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, jcuda.jcublas.cuDoubleComplex[], int, int, Pointer, int)">cublasSetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;A,
                int&nbsp;offsetA,
                int&nbsp;lda,
                Pointer&nbsp;B,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuDoubleComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)">cublasSetMatrix</A></B>(int&nbsp;rows,
                int&nbsp;cols,
                int&nbsp;elemSize,
                Pointer&nbsp;A,
                int&nbsp;lda,
                Pointer&nbsp;B,
                int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrixAsync(int, int, int, Pointer, int, Pointer, int, cudaStream_t)">cublasSetMatrixAsync</A></B>(int&nbsp;rows,
                     int&nbsp;cols,
                     int&nbsp;elemSize,
                     Pointer&nbsp;A,
                     int&nbsp;lda,
                     Pointer&nbsp;B,
                     int&nbsp;ldb,
                     cudaStream_t&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVector(int, jcuda.jcublas.cuComplex[], int, int, Pointer, int)">cublasSetVector</A></B>(int&nbsp;n,
                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;x,
                int&nbsp;offsetx,
                int&nbsp;incx,
                Pointer&nbsp;y,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVector(int, jcuda.jcublas.cuDoubleComplex[], int, int, Pointer, int)">cublasSetVector</A></B>(int&nbsp;n,
                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;x,
                int&nbsp;offsetx,
                int&nbsp;incx,
                Pointer&nbsp;y,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended wrapper for arrays of cuDoubleComplex values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVector(int, int, Pointer, int, Pointer, int)">cublasSetVector</A></B>(int&nbsp;n,
                int&nbsp;elemSize,
                Pointer&nbsp;x,
                int&nbsp;incx,
                Pointer&nbsp;y,
                int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVectorAsync(int, int, Pointer, int, Pointer, int, cudaStream_t)">cublasSetVectorAsync</A></B>(int&nbsp;n,
                     int&nbsp;elemSize,
                     Pointer&nbsp;hostPtr,
                     int&nbsp;incx,
                     Pointer&nbsp;devicePtr,
                     int&nbsp;incy,
                     cudaStream_t&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSgbmv(char, int, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSgbmv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;kl,
            int&nbsp;ku,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            float&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSgbmv (char trans, int m, int n, int kl, int ku, float alpha,
              const float *A, int lda, const float *x, int incx, float beta,
              float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision scalars. x and y are single precision
 vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSgemm(char, char, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSgemm</A></B>(char&nbsp;transa,
            char&nbsp;transb,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;k,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            float&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSgemm (char transa, char transb, int m, int n, int k, float alpha, 
              const float *A, int lda, const float *B, int ldb, float beta, 
              float *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by a scalar alpha, and adds the sum to the product of matrix C and
 scalar beta. sgemm() performs one of the matrix-matrix operations:

     C = alpha * op(A) * op(B) + beta * C,

 where op(X) is one of

     op(X) = X   or   op(X) = transpose(X)

 alpha and beta are single precision scalars, and A, B and C are 
 matrices consisting of single precision elements, with op(A) an m x k 
 matrix, op(B) a k x n matrix, and C an m x n matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSgemv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSgemv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            float&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasSgemv (char trans, int m, int n, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSger(int, int, float, Pointer, int, Pointer, int, Pointer, int)">cublasSger</A></B>(int&nbsp;m,
           int&nbsp;n,
           float&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasSger (int m, int n, float alpha, const float *x, int incx, 
             const float *y, int incy, float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision scalar, x is an m element single 
 precision vector, y is an n element single precision vector, and A 
 is an m by n matrix consisting of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasShutdown()">cublasShutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSnrm2(int, Pointer, int)">cublasSnrm2</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 float 
 cublasSnrm2 (int n, const float *x, int incx)

 computes the Euclidean norm of the single precision n-vector x (with
 storage increment incx).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSrot(int, Pointer, int, Pointer, int, float, float)">cublasSrot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           float&nbsp;sc,
           float&nbsp;ss)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSrot (int n, float *x, int incx, float *y, int incy, float sc, 
             float ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSrotg(Pointer, Pointer, Pointer, Pointer)">cublasSrotg</A></B>(Pointer&nbsp;host_sa,
            Pointer&nbsp;host_sb,
            Pointer&nbsp;host_sc,
            Pointer&nbsp;host_ss)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSrotg (float *host_sa, float *host_sb, float *host_sc, float *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSrotm(int, Pointer, int, Pointer, int, float[])">cublasSrotm</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            float[]&nbsp;sparam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSrotmg(float[], float[], float[], float, float[])">cublasSrotmg</A></B>(float[]&nbsp;sd1,
             float[]&nbsp;sd2,
             float[]&nbsp;sx1,
             float&nbsp;sy1,
             float[]&nbsp;sparam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper for CUBLAS function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsbmv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSsbmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            int&nbsp;k,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            float&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsbmv (char uplo, int n, int k, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision scalars. x and y are single precision
 vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSscal(int, float, Pointer, int)">cublasSscal</A></B>(int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 sscal (int n, float alpha, float *x, int incx)

 replaces single precision vector x with single precision alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSspmv(char, int, float, Pointer, Pointer, int, float, Pointer, int)">cublasSspmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx,
            float&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSspmv (char uplo, int n, float alpha, const float *AP, const float *x,
              int incx, float beta, float *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSspr(char, int, float, Pointer, int, Pointer)">cublasSspr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           float&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSspr (char uplo, int n, float alpha, const float *x, int incx, 
             float *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a single precision scalar and x is an n element single 
 precision vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSspr2(char, int, float, Pointer, int, Pointer, int, Pointer)">cublasSspr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 void 
 cublasSspr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, and x and y are n element single 
 precision vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSswap(int, Pointer, int, Pointer, int)">cublasSswap</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasSswap (int n, float *x, int incx, float *y, int incy)

 replaces single precision vector x with single precision alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsymm(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSsymm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            float&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsymm (char side, char uplo, int m, int n, float alpha, 
              const float *A, int lda, const float *B, int ldb, 
              float beta, float *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision scalars, A is a symmetric matrix
 consisting of single precision elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsymv(char, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSsymv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            float&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsymv (char uplo, int n, float alpha, const float *A, int lda, 
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors, each with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsyr(char, int, float, Pointer, int, Pointer, int)">cublasSsyr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           float&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsyr (char uplo, int n, float alpha, const float *x, int incx,
             float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a single precision scalar, x is an n element single 
 precision vector and A is an n x n symmetric matrix consisting of 
 single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsyr2(char, int, float, Pointer, int, Pointer, int, Pointer, int)">cublasSsyr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsyr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, x and y are n element single 
 precision vector and A is an n by n symmetric matrix consisting of single 
 precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsyr2k(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)">cublasSsyr2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             float&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             float&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsyr2k (char uplo, char trans, int n, int k, float alpha, 
               const float *A, int lda, const float *B, int ldb, 
               float beta, float *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasSsyrk(char, char, int, int, float, Pointer, int, float, Pointer, int)">cublasSsyrk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            float&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasSsyrk (char uplo, char trans, int n, int k, float alpha, 
              const float *A, int lda, float beta, float *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStbmv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasStbmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStbmv (char uplo, char trans, char diag, int n, int k, const float *A,
              int lda, float *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A
 or op(A) = transpose(A). x is an n-element single precision vector, and A is
 an n x n, unit or non-unit upper or lower triangular band matrix consisting
 of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStbsv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasStbsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasStbsv (char uplo, char trans, char diag, int n, int k,
                   const float *A, int lda, float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n-element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStpmv(char, char, char, int, Pointer, Pointer, int)">cublasStpmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStpmv (char uplo, char trans, char diag, int n, const float *AP, 
              float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element single precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStpsv(char, char, char, int, Pointer, Pointer, int)">cublasStpsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStpsv (char uplo, char trans, char diag, int n, const float *AP,
              float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStrmm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)">cublasStrmm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStrmm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, const float *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision scalar, B is an m x n matrix composed
 of single precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStrmv(char, char, char, int, Pointer, int, Pointer, int)">cublasStrmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStrmv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStrsm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)">cublasStrsm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            float&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStrsm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, float *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision scalar, and X and B are m x n matrices 
 that are composed of single precision elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasStrsv(char, char, char, int, Pointer, int, Pointer, int)">cublasStrsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasStrsv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are single precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZaxpy(int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)">cublasZaxpy</A></B>(int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZaxpy (int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              cuDoubleComplex *y, int incy)

 multiplies double-complex vector x by double-complex scalar alpha and adds 
 the result to double-complex vector y; that is, it overwrites double-complex
 y with double-complex alpha * x + y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZcopy(int, Pointer, int, Pointer, int)">cublasZcopy</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZcopy (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 copies the double-complex vector x to the double-complex vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZdrot(int, Pointer, int, Pointer, int, double, double)">cublasZdrot</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            double&nbsp;c,
            double&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 zdrot (int n, cuDoubleComplex *x, int incx, cuCumplex *y, int incy, double c, 
        double s)

 multiplies a 2x2 matrix ( c s) with the 2xn matrix ( transpose(x) )
                         (-s c)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZdscal(int, double, Pointer, int)">cublasZdscal</A></B>(int&nbsp;n,
             double&nbsp;alpha,
             Pointer&nbsp;x,
             int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZdscal (int n, double alpha, cuDoubleComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZgbmv(char, int, int, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZgbmv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;kl,
            int&nbsp;ku,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZgbmv (char trans, int m, int n, int kl, int ku, cuDoubleComplex alpha,
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, cuDoubleComplex beta,
              cuDoubleComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZgemm(char, char, int, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZgemm</A></B>(char&nbsp;transa,
            char&nbsp;transb,
            int&nbsp;m,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasZgemm (char transa, char transb, int m, int n, int k,
                   cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
                   const cuDoubleComplex *B, int ldb, cuDoubleComplex beta,
                   cuDoubleComplex *C, int ldc)

 zgemm performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are double-complex scalars, and A, B and C are matrices
 consisting of double-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZgemv(char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZgemv</A></B>(char&nbsp;trans,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasZgemv (char trans, int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZgerc(int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)">cublasZgerc</A></B>(int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasZgerc (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZgeru(int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)">cublasZgeru</A></B>(int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasZgeru (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhbmv(char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZhbmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZhbmv (char uplo, int n, int k, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhemm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZhemm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZhemm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a hermitian matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhemv(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZhemv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZhemv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, 
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors, each with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZher(char, int, double, Pointer, int, Pointer, int)">cublasZher</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           double&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;A,
           int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZher (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a double precision real scalar, x is an n element double 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZher2(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)">cublasZher2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasZher2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
                   const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, x and y are n element double 
 precision complex vector and A is an n by n hermitian matrix consisting of double 
 precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZher2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, double, Pointer, int)">cublasZher2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             double&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZher2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZherk(char, char, int, int, double, Pointer, int, double, Pointer, int)">cublasZherk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            double&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            double&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZherk (char uplo, char trans, int n, int k, double alpha, 
              const cuDoubleComplex *A, int lda, double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhpmv(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZhpmv</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZhpmv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *AP, const cuDoubleComplex *x,
              int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors with n elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhpr(char, int, double, Pointer, int, Pointer)">cublasZhpr</A></B>(char&nbsp;uplo,
           int&nbsp;n,
           double&nbsp;alpha,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZhpr (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a double precision real scalar and x is an n element double 
 precision complex vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZhpr2(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer)">cublasZhpr2</A></B>(char&nbsp;uplo,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy,
            Pointer&nbsp;AP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 void 
 cublasZhpr2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              const cuDoubleComplex *y, int incy, cuDoubleComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, and x and y are n element double 
 precision complex vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZrot(int, Pointer, int, Pointer, int, double, jcuda.jcublas.cuDoubleComplex)">cublasZrot</A></B>(int&nbsp;n,
           Pointer&nbsp;x,
           int&nbsp;incx,
           Pointer&nbsp;y,
           int&nbsp;incy,
           double&nbsp;sc,
           <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;cs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 cublasZrot (int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy, double sc,
             cuDoubleComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZrotg(Pointer, jcuda.jcublas.cuDoubleComplex, Pointer, Pointer)">cublasZrotg</A></B>(Pointer&nbsp;host_ca,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;cb,
            Pointer&nbsp;host_sc,
            Pointer&nbsp;host_cs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZrotg (cuDoubleComplex *host_ca, cuDoubleComplex cb, double *host_sc, double *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZscal(int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZscal</A></B>(int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZswap(int, Pointer, int, Pointer, int)">cublasZswap</A></B>(int&nbsp;n,
            Pointer&nbsp;x,
            int&nbsp;incx,
            Pointer&nbsp;y,
            int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZswap (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 interchanges the double-complex vector x with the double-complex vector y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZsymm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZsymm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZsymm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a symmetric matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZsyr2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZsyr2k</A></B>(char&nbsp;uplo,
             char&nbsp;trans,
             int&nbsp;n,
             int&nbsp;k,
             <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
             Pointer&nbsp;A,
             int&nbsp;lda,
             Pointer&nbsp;B,
             int&nbsp;ldb,
             <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
             Pointer&nbsp;C,
             int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZsyr2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZsyrk(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)">cublasZsyrk</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            int&nbsp;n,
            int&nbsp;k,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
            Pointer&nbsp;C,
            int&nbsp;ldc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZsyrk (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtbmv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasZtbmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtbmv (char uplo, char trans, char diag, int n, int k, const cuDoubleComplex *A,
              int lda, cuDoubleComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtbsv(char, char, char, int, int, Pointer, int, Pointer, int)">cublasZtbsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            int&nbsp;k,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void cublasZtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuDoubleComplex *A, int lda, cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtpmv(char, char, char, int, Pointer, Pointer, int)">cublasZtpmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtpmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtpsv(char, char, char, int, Pointer, Pointer, int)">cublasZtpsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;AP,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtpsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtrmm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)">cublasZtrmm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision complex scalar, B is an m x n matrix composed
 of double precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtrmv(char, char, char, int, Pointer, int, Pointer, int)">cublasZtrmv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtrmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtrsm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)">cublasZtrsm</A></B>(char&nbsp;side,
            char&nbsp;uplo,
            char&nbsp;transa,
            char&nbsp;diag,
            int&nbsp;m,
            int&nbsp;n,
            <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;B,
            int&nbsp;ldb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void
 cublasZtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              cuDoubleComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision complex scalar, and X and B are m x n matrices
 that are composed of double precision complex elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#cublasZtrsv(char, char, char, int, Pointer, int, Pointer, int)">cublasZtrsv</A></B>(char&nbsp;uplo,
            char&nbsp;trans,
            char&nbsp;diag,
            int&nbsp;n,
            Pointer&nbsp;A,
            int&nbsp;lda,
            Pointer&nbsp;x,
            int&nbsp;incx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 void 
 cublasZtrsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are double precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#initialize()">initialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the native library.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#printMatrix(int, Pointer, int)">printMatrix</A></B>(int&nbsp;cols,
            Pointer&nbsp;A,
            int&nbsp;lda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#printVector(int, Pointer)">printVector</A></B>(int&nbsp;n,
            Pointer&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#setEmulation(boolean)">setEmulation</A></B>(boolean&nbsp;emulation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>The emulation mode has been deprecated in
 CUDA 3.0. This function no longer has any effect, and
 will be removed in the next release.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#setExceptionsEnabled(boolean)">setExceptionsEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables exceptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/jcublas/JCublas.html#setLogLevel(LogLevel)">setLogLevel</A></B>(LogLevel&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified log level for the JCublas library.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setEmulation(boolean)"><!-- --></A><H3>
setEmulation</H3>
<PRE>
public static void <B>setEmulation</B>(boolean&nbsp;emulation)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>The emulation mode has been deprecated in
 CUDA 3.0. This function no longer has any effect, and
 will be removed in the next release.</I>
<P>
<DD>Set the flag which indicates whether the emulation mode
 should be used.<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLogLevel(LogLevel)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public static void <B>setLogLevel</B>(LogLevel&nbsp;logLevel)</PRE>
<DL>
<DD>Set the specified log level for the JCublas library.<br />
 <br />
 Currently supported log levels:
 <br />
 LOG_QUIET: Never print anything <br />
 LOG_ERROR: Print error messages <br />
 LOG_TRACE: Print a trace of all native function calls <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The log level to use.</DL>
</DD>
</DL>
<HR>

<A NAME="setExceptionsEnabled(boolean)"><!-- --></A><H3>
setExceptionsEnabled</H3>
<PRE>
public static void <B>setExceptionsEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enables or disables exceptions. By default, the methods of this class
 only set the result status which may be queried with 
 <A HREF="../../jcuda/jcublas/JCublas.html#cublasGetError()"><CODE>cublasGetError()</CODE></A>.
 If exceptions are enabled, a CudaException with a detailed error 
 message will be thrown if a method is about to set a result code 
 that is not cublasStatus.CUBLAS_STATUS_SUCCESS
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - Whether exceptions are enabled</DL>
</DD>
</DL>
<HR>

<A NAME="initialize()"><!-- --></A><H3>
initialize</H3>
<PRE>
public static void <B>initialize</B>()</PRE>
<DL>
<DD>Initializes the native library. Note that this method
 does not have to be called explicitly, since it will
 be called automatically from <A HREF="../../jcuda/jcublas/JCublas.html#cublasInit()"><CODE>cublasInit()</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasInit()"><!-- --></A><H3>
cublasInit</H3>
<PRE>
public static int <B>cublasInit</B>()</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasInit()<br />
<br />
 initializes the CUBLAS library and must be called before any other
 CUBLAS API function is invoked. It allocates hardware resources
 necessary for accessing the GPU.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_ALLOC_FAILED     if resources could not be allocated<br />
 CUBLAS_STATUS_SUCCESS          if CUBLAS library initialized successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasShutdown()"><!-- --></A><H3>
cublasShutdown</H3>
<PRE>
public static int <B>cublasShutdown</B>()</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasShutdown()<br />
<br />
 releases CPU-side resources used by the CUBLAS library. The release of
 GPU-side resources may be deferred until the application shuts down.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized<br />
 CUBLAS_STATUS_SUCCESS          if CUBLAS library shut down successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetError()"><!-- --></A><H3>
cublasGetError</H3>
<PRE>
public static int <B>cublasGetError</B>()</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasGetError()<br />
<br />
 returns the last error that occurred on invocation of any of the
 CUBLAS BLAS functions. While the CUBLAS helper functions return status
 directly, the BLAS functions do not do so for improved
 compatibility with existing environments that do not expect BLAS
 functions to return status. Reading the error status via
 cublasGetError() resets the internal error state to
 CUBLAS_STATUS_SUCCESS.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasAlloc(int, int, Pointer)"><!-- --></A><H3>
cublasAlloc</H3>
<PRE>
public static int <B>cublasAlloc</B>(int&nbsp;n,
                              int&nbsp;elemSize,
                              Pointer&nbsp;ptr)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasAlloc (int n, int elemSize, void **devicePtr)<br />
<br />
 creates an object in GPU memory space capable of holding an array of
 n elements, where each element requires elemSize bytes of storage. If
 the function call is successful, a pointer to the object in GPU memory
 space is placed in devicePtr. Note that this is a device pointer that
 cannot be dereferenced in host code.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized<br />
 CUBLAS_STATUS_INVALID_VALUE    if n <= 0, or elemSize <= 0<br />
 CUBLAS_STATUS_ALLOC_FAILED     if the object could not be allocated due to
                                lack of resources.<br />
 CUBLAS_STATUS_SUCCESS          if storage was successfully allocated<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasFree(Pointer)"><!-- --></A><H3>
cublasFree</H3>
<PRE>
public static int <B>cublasFree</B>(Pointer&nbsp;ptr)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasFree (const void *devicePtr)<br />
<br />
 destroys the object in GPU memory space pointed to by devicePtr.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized<br />
 CUBLAS_STATUS_INTERNAL_ERROR   if the object could not be deallocated<br />
 CUBLAS_STATUS_SUCCESS          if object was destroyed successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printVector(int, Pointer)"><!-- --></A><H3>
printVector</H3>
<PRE>
public static void <B>printVector</B>(int&nbsp;n,
                               Pointer&nbsp;x)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix(int, Pointer, int)"><!-- --></A><H3>
printMatrix</H3>
<PRE>
public static void <B>printMatrix</B>(int&nbsp;cols,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetVector(int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSetVector</H3>
<PRE>
public static int <B>cublasSetVector</B>(int&nbsp;n,
                                  int&nbsp;elemSize,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx,
                                  Pointer&nbsp;y,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus<br />
 cublasSetVector (int n, int elemSize, const void *x, int incx,
                  void *y, int incy)<br />
<br />
 copies n elements from a vector x in CPU memory space to a vector y
 in GPU memory space. Elements in both vectors are assumed to have a
 size of elemSize bytes. Storage spacing between consecutive elements
 is incx for the source vector x and incy for the destination vector
 y. In general, y points to an object, or part of an object, allocated
 via cublasAlloc(). Column major format for two-dimensional matrices
 is assumed throughout CUBLAS. Therefore, if the increment for a vector
 is equal to 1, this access a column vector while using an increment
 equal to the leading dimension of the respective matrix accesses a
 row vector.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library not been initialized<br />
 CUBLAS_STATUS_INVALID_VALUE    if incx, incy, or elemSize <= 0<br />
 CUBLAS_STATUS_MAPPING_ERROR    if an error occurred accessing GPU memory<br />
 CUBLAS_STATUS_SUCCESS          if the operation completed successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetVector(int, jcuda.jcublas.cuComplex[], int, int, Pointer, int)"><!-- --></A><H3>
cublasSetVector</H3>
<PRE>
public static int <B>cublasSetVector</B>(int&nbsp;n,
                                  <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;x,
                                  int&nbsp;offsetx,
                                  int&nbsp;incx,
                                  Pointer&nbsp;y,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a float array containing
 the complex numbers, where each pair of consecutive numbers in the array
 describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVector(int, int, Pointer, int, Pointer, int)"><CODE>cublasSetVector(int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetVector(int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasGetVector</H3>
<PRE>
public static int <B>cublasGetVector</B>(int&nbsp;n,
                                  int&nbsp;elemSize,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx,
                                  Pointer&nbsp;y,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus<br />
 cublasGetVector (int n, int elemSize, const void *x, int incx,
                  void *y, int incy)<br />
<br />
 copies n elements from a vector x in GPU memory space to a vector y
 in CPU memory space. Elements in both vectors are assumed to have a
 size of elemSize bytes. Storage spacing between consecutive elements
 is incx for the source vector x and incy for the destination vector
 y. In general, x points to an object, or part of an object, allocated
 via cublasAlloc(). Column major format for two-dimensional matrices
 is assumed throughout CUBLAS. Therefore, if the increment for a vector
 is equal to 1, this access a column vector while using an increment
 equal to the leading dimension of the respective matrix accesses a
 row vector.<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library not been initialized<br />
 CUBLAS_STATUS_INVALID_VALUE    if incx, incy, or elemSize <= 0<br />
 CUBLAS_STATUS_MAPPING_ERROR    if an error occurred accessing GPU memory<br />
 CUBLAS_STATUS_SUCCESS          if the operation completed successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetVector(int, Pointer, int, jcuda.jcublas.cuComplex[], int, int)"><!-- --></A><H3>
cublasGetVector</H3>
<PRE>
public static int <B>cublasGetVector</B>(int&nbsp;n,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx,
                                  <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;y,
                                  int&nbsp;offsety,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a float array that may
 store the complex numbers, where each pair of consecutive numbers in
 the array describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVector(int, int, Pointer, int, Pointer, int)"><CODE>cublasGetVector(int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSetMatrix</H3>
<PRE>
public static int <B>cublasSetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  int&nbsp;elemSize,
                                  Pointer&nbsp;A,
                                  int&nbsp;lda,
                                  Pointer&nbsp;B,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasSetMatrix (int rows, int cols, int elemSize, const void *A,
                  int lda, void *B, int ldb)<br />
<br />
 copies a tile of rows x cols elements from a matrix A in CPU memory
 space to a matrix B in GPU memory space. Each element requires storage
 of elemSize bytes. Both matrices are assumed to be stored in column
 major format, with the leading dimension (i.e. number of rows) of
 source matrix A provided in lda, and the leading dimension of matrix B
 provided in ldb. In general, B points to an object, or part of an
 object, that was allocated via cublasAlloc().<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized<br />
 CUBLAS_STATUS_INVALID_VALUE    if rows or cols < 0, or elemSize, lda, or
                                ldb <= 0<br />
 CUBLAS_STATUS_MAPPING_ERROR    if error occurred accessing GPU memory<br />
 CUBLAS_STATUS_SUCCESS          if the operation completed successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetMatrix(int, int, jcuda.jcublas.cuComplex[], int, int, Pointer, int)"><!-- --></A><H3>
cublasSetMatrix</H3>
<PRE>
public static int <B>cublasSetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;A,
                                  int&nbsp;offsetA,
                                  int&nbsp;lda,
                                  Pointer&nbsp;B,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a float array containing
 the complex numbers, where each pair of consecutive numbers in the array
 describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)"><CODE>cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasGetMatrix</H3>
<PRE>
public static int <B>cublasGetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  int&nbsp;elemSize,
                                  Pointer&nbsp;A,
                                  int&nbsp;lda,
                                  Pointer&nbsp;B,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.<br />
 <br />
 cublasStatus
 cublasGetMatrix (int rows, int cols, int elemSize, const void *A,
                  int lda, void *B, int ldb)<br />
<br />
 copies a tile of rows x cols elements from a matrix A in GPU memory
 space to a matrix B in CPU memory space. Each element requires storage
 of elemSize bytes. Both matrices are assumed to be stored in column
 major format, with the leading dimension (i.e. number of rows) of
 source matrix A provided in lda, and the leading dimension of matrix B
 provided in ldb. In general, A points to an object, or part of an
 object, that was allocated via cublasAlloc().<br />
<br />
 Return Values<br />
 -------------<br />
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized<br />
 CUBLAS_STATUS_INVALID_VALUE    if rows, cols, eleSize, lda, or ldb <= 0<br />
 CUBLAS_STATUS_MAPPING_ERROR    if error occurred accessing GPU memory<br />
 CUBLAS_STATUS_SUCCESS          if the operation completed successfully<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetMatrix(int, int, Pointer, int, jcuda.jcublas.cuComplex[], int, int)"><!-- --></A><H3>
cublasGetMatrix</H3>
<PRE>
public static int <B>cublasGetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  Pointer&nbsp;A,
                                  int&nbsp;lda,
                                  <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>[]&nbsp;B,
                                  int&nbsp;offsetB,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a float array that may
 store the complex numbers, where each pair of consecutive numbers in
 the array describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)"><CODE>cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetVector(int, jcuda.jcublas.cuDoubleComplex[], int, int, Pointer, int)"><!-- --></A><H3>
cublasSetVector</H3>
<PRE>
public static int <B>cublasSetVector</B>(int&nbsp;n,
                                  <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;x,
                                  int&nbsp;offsetx,
                                  int&nbsp;incx,
                                  Pointer&nbsp;y,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuDoubleComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a double array containing
 the complex numbers, where each pair of consecutive numbers in the array
 describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetVector(int, int, Pointer, int, Pointer, int)"><CODE>cublasSetVector(int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetVector(int, Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)"><!-- --></A><H3>
cublasGetVector</H3>
<PRE>
public static int <B>cublasGetVector</B>(int&nbsp;n,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx,
                                  <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;y,
                                  int&nbsp;offsety,
                                  int&nbsp;incy)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuDoubleComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a double array that may
 store the complex numbers, where each pair of consecutive numbers in
 the array describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetVector(int, int, Pointer, int, Pointer, int)"><CODE>cublasGetVector(int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetMatrix(int, int, jcuda.jcublas.cuDoubleComplex[], int, int, Pointer, int)"><!-- --></A><H3>
cublasSetMatrix</H3>
<PRE>
public static int <B>cublasSetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;A,
                                  int&nbsp;offsetA,
                                  int&nbsp;lda,
                                  Pointer&nbsp;B,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuDoubleComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a double array containing
 the complex numbers, where each pair of consecutive numbers in the array
 describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)"><CODE>cublasSetMatrix(int, int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetMatrix(int, int, Pointer, int, jcuda.jcublas.cuDoubleComplex[], int, int)"><!-- --></A><H3>
cublasGetMatrix</H3>
<PRE>
public static int <B>cublasGetMatrix</B>(int&nbsp;rows,
                                  int&nbsp;cols,
                                  Pointer&nbsp;A,
                                  int&nbsp;lda,
                                  <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>[]&nbsp;B,
                                  int&nbsp;offsetB,
                                  int&nbsp;ldb)</PRE>
<DL>
<DD>Extended wrapper for arrays of cuDoubleComplex values. Note that this method
 only exists for convenience and compatibility with native C code. It
 is much more efficient to provide a Pointer to a double array that may
 store the complex numbers, where each pair of consecutive numbers in
 the array describes the real- and imaginary part of one complex number.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/jcublas/JCublas.html#cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)"><CODE>cublasGetMatrix(int, int, int, Pointer, int, Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetKernelStream(cudaStream_t)"><!-- --></A><H3>
cublasSetKernelStream</H3>
<PRE>
public static int <B>cublasSetKernelStream</B>(cudaStream_t&nbsp;stream)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetVectorAsync(int, int, Pointer, int, Pointer, int, cudaStream_t)"><!-- --></A><H3>
cublasSetVectorAsync</H3>
<PRE>
public static int <B>cublasSetVectorAsync</B>(int&nbsp;n,
                                       int&nbsp;elemSize,
                                       Pointer&nbsp;hostPtr,
                                       int&nbsp;incx,
                                       Pointer&nbsp;devicePtr,
                                       int&nbsp;incy,
                                       cudaStream_t&nbsp;stream)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetVectorAsync(int, int, Pointer, int, Pointer, int, cudaStream_t)"><!-- --></A><H3>
cublasGetVectorAsync</H3>
<PRE>
public static int <B>cublasGetVectorAsync</B>(int&nbsp;n,
                                       int&nbsp;elemSize,
                                       Pointer&nbsp;devicePtr,
                                       int&nbsp;incx,
                                       Pointer&nbsp;hostPtr,
                                       int&nbsp;incy,
                                       cudaStream_t&nbsp;stream)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSetMatrixAsync(int, int, int, Pointer, int, Pointer, int, cudaStream_t)"><!-- --></A><H3>
cublasSetMatrixAsync</H3>
<PRE>
public static int <B>cublasSetMatrixAsync</B>(int&nbsp;rows,
                                       int&nbsp;cols,
                                       int&nbsp;elemSize,
                                       Pointer&nbsp;A,
                                       int&nbsp;lda,
                                       Pointer&nbsp;B,
                                       int&nbsp;ldb,
                                       cudaStream_t&nbsp;stream)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasGetMatrixAsync(int, int, int, Pointer, int, Pointer, int, cudaStream_t)"><!-- --></A><H3>
cublasGetMatrixAsync</H3>
<PRE>
public static int <B>cublasGetMatrixAsync</B>(int&nbsp;rows,
                                       int&nbsp;cols,
                                       int&nbsp;elemSize,
                                       Pointer&nbsp;A,
                                       int&nbsp;lda,
                                       Pointer&nbsp;B,
                                       int&nbsp;ldb,
                                       cudaStream_t&nbsp;stream)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSrotm(int, Pointer, int, Pointer, int, float[])"><!-- --></A><H3>
cublasSrotm</H3>
<PRE>
public static void <B>cublasSrotm</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               float[]&nbsp;sparam)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.
 <pre>
 void
 cublasSrotm (int n, float *x, int incx, float *y, int incy,
              const float* sparam)

 applies the modified Givens transformation, h, to the 2 x n matrix

    ( transpose(x) )
    ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 to n-1, where lx = 1 if
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and
 incy. With sparam[0] = sflag, h has one of the following forms:

        sflag = -1.0f   sflag = 0.0f    sflag = 1.0f    sflag = -2.0f

        (sh00  sh01)    (1.0f  sh01)    (sh00  1.0f)    (1.0f  0.0f)
    h = (          )    (          )    (          )    (          )
        (sh10  sh11)    (sh10  1.0f)    (-1.0f sh11)    (0.0f  1.0f)

 Input
 -----
 n      number of elements in input vectors
 x      single precision vector with n elements
 incx   storage spacing between elements of x
 y      single precision vector with n elements
 incy   storage spacing between elements of y
 sparam 5-element vector. sparam[0] is sflag described above. sparam[1]
        through sparam[4] contain the 2x2 rotation matrix h: sparam[1]
        contains sh00, sparam[2] contains sh10, sparam[3] contains sh01,
        and sprams[4] contains sh11.

 Output
 ------
 x     rotated vector x (unchanged if n <= 0)
 y     rotated vector y (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/srotm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSrotmg(float[], float[], float[], float, float[])"><!-- --></A><H3>
cublasSrotmg</H3>
<PRE>
public static void <B>cublasSrotmg</B>(float[]&nbsp;sd1,
                                float[]&nbsp;sd2,
                                float[]&nbsp;sx1,
                                float&nbsp;sy1,
                                float[]&nbsp;sparam)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.
 <pre>
 void
 cublasSrotmg (float *psd1, float *psd2, float *psx1, const float *psy1,
                float *sparam)

 constructs the modified Givens transformation matrix h which zeros
 the second component of the 2-vector transpose(sqrt(sd1)*sx1,sqrt(sd2)*sy1).
 With sparam[0] = sflag, h has one of the following forms:

        sflag = -1.0f   sflag = 0.0f    sflag = 1.0f    sflag = -2.0f

        (sh00  sh01)    (1.0f  sh01)    (sh00  1.0f)    (1.0f  0.0f)
    h = (          )    (          )    (          )    (          )
        (sh10  sh11)    (sh10  1.0f)    (-1.0f sh11)    (0.0f  1.0f)

 sparam[1] through sparam[4] contain sh00, sh10, sh01, sh11,
 respectively. Values of 1.0f, -1.0f, or 0.0f implied by the value
 of sflag are not stored in sparam.

 Input
 -----
 sd1    single precision scalar
 sd2    single precision scalar
 sx1    single precision scalar
 sy1    single precision scalar

 Output
 ------
 sd1    changed to represent the effect of the transformation
 sd2    changed to represent the effect of the transformation
 sx1    changed to represent the effect of the transformation
 sparam 5-element vector. sparam[0] is sflag described above. sparam[1]
        through sparam[4] contain the 2x2 rotation matrix h: sparam[1]
        contains sh00, sparam[2] contains sh10, sparam[3] contains sh01,
        and sprams[4] contains sh11.

 Reference: http://www.netlib.org/blas/srotmg.f

 This functions does not set any error status.
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDrotm(int, Pointer, int, Pointer, int, double[])"><!-- --></A><H3>
cublasDrotm</H3>
<PRE>
public static void <B>cublasDrotm</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               double[]&nbsp;sparam)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.
 <pre>
 void
 cublasDrotm (int n, double *x, int incx, double *y, int incy,
              const double* sparam)

 applies the modified Givens transformation, h, to the 2 x n matrix

    ( transpose(x) )
    ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 to n-1, where lx = 1 if
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and
 incy. With sparam[0] = sflag, h has one of the following forms:

        sflag = -1.0    sflag = 0.0     sflag = 1.0     sflag = -2.0

        (sh00  sh01)    (1.0   sh01)    (sh00   1.0)    (1.0    0.0)
    h = (          )    (          )    (          )    (          )
        (sh10  sh11)    (sh10   1.0)    (-1.0  sh11)    (0.0    1.0)

 Input
 -----
 n      number of elements in input vectors
 x      double-precision vector with n elements
 incx   storage spacing between elements of x
 y      double-precision vector with n elements
 incy   storage spacing between elements of y
 sparam 5-element vector. sparam[0] is sflag described above. sparam[1]
        through sparam[4] contain the 2x2 rotation matrix h: sparam[1]
        contains sh00, sparam[2] contains sh10, sparam[3] contains sh01,
        and sprams[4] contains sh11.

 Output
 ------
 x     rotated vector x (unchanged if n <= 0)
 y     rotated vector y (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/drotm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDrotmg(double[], double[], double[], double, double[])"><!-- --></A><H3>
cublasDrotmg</H3>
<PRE>
public static void <B>cublasDrotmg</B>(double[]&nbsp;sd1,
                                double[]&nbsp;sd2,
                                double[]&nbsp;sx1,
                                double&nbsp;sy1,
                                double[]&nbsp;sparam)</PRE>
<DL>
<DD>Wrapper for CUBLAS function.
 <pre>
 void
 cublasDrotmg (double *psd1, double *psd2, double *psx1, const double *psy1,
               double *sparam)

 constructs the modified Givens transformation matrix h which zeros
 the second component of the 2-vector transpose(sqrt(sd1)*sx1,sqrt(sd2)*sy1).
 With sparam[0] = sflag, h has one of the following forms:

        sflag = -1.0    sflag = 0.0     sflag = 1.0     sflag = -2.0

        (sh00  sh01)    (1.0   sh01)    (sh00   1.0)    (1.0    0.0)
    h = (          )    (          )    (          )    (          )
        (sh10  sh11)    (sh10   1.0)    (-1.0  sh11)    (0.0    1.0)

 sparam[1] through sparam[4] contain sh00, sh10, sh01, sh11,
 respectively. Values of 1.0, -1.0, or 0.0 implied by the value
 of sflag are not stored in sparam.

 Input
 -----
 sd1    single precision scalar
 sd2    single precision scalar
 sx1    single precision scalar
 sy1    single precision scalar

 Output
 ------
 sd1    changed to represent the effect of the transformation
 sd2    changed to represent the effect of the transformation
 sx1    changed to represent the effect of the transformation
 sparam 5-element vector. sparam[0] is sflag described above. sparam[1]
        through sparam[4] contain the 2x2 rotation matrix h: sparam[1]
        contains sh00, sparam[2] contains sh10, sparam[3] contains sh01,
        and sprams[4] contains sh11.

 Reference: http://www.netlib.org/blas/drotmg.f

 This functions does not set any error status.

 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIsamax(int, Pointer, int)"><!-- --></A><H3>
cublasIsamax</H3>
<PRE>
public static int <B>cublasIsamax</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIsamax (int n, const float *x, int incx)

 finds the smallest index of the maximum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/isamax.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIsamin(int, Pointer, int)"><!-- --></A><H3>
cublasIsamin</H3>
<PRE>
public static int <B>cublasIsamin</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIsamin (int n, const float *x, int incx)

 finds the smallest index of the minimum magnitude element of single
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/scilib/blass.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSasum(int, Pointer, int)"><!-- --></A><H3>
cublasSasum</H3>
<PRE>
public static float <B>cublasSasum</B>(int&nbsp;n,
                                Pointer&nbsp;x,
                                int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 float 
 cublasSasum (int n, const float *x, int incx)

 computes the sum of the absolute values of the elements of single 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).
 
 Input
 -----
 n      number of elements in input vector
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the single precision sum of absolute values
 (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/sasum.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSaxpy(int, float, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSaxpy</H3>
<PRE>
public static void <B>cublasSaxpy</B>(int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasSaxpy (int n, float alpha, const float *x, int incx, float *y, 
              int incy)

 multiplies single precision vector x by single precision scalar alpha 
 and adds the result to single precision vector y; that is, it overwrites 
 single precision y with single precision alpha * x + y. For i = 0 to n - 1, 
 it replaces y[ly + i * incy] with alpha * x[lx + i * incx] + y[ly + i *
 incy], where lx = 1 if incx >= 0, else lx = 1 +(1 - n) * incx, and ly is 
 defined in a similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 alpha  single precision scalar multiplier
 x      single precision vector with n elements
 incx   storage spacing between elements of x
 y      single precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      single precision result (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/saxpy.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasScopy(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasScopy</H3>
<PRE>
public static void <B>cublasScopy</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasScopy (int n, const float *x, int incx, float *y, int incy)

 copies the single precision vector x to the single precision vector y. For 
 i = 0 to n-1, copies x[lx + i * incx] to y[ly + i * incy], where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a similar 
 way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      single precision vector with n elements
 incx   storage spacing between elements of x
 y      single precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      contains single precision vector x

 Reference: http://www.netlib.org/blas/scopy.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSdot(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSdot</H3>
<PRE>
public static float <B>cublasSdot</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 float 
 cublasSdot (int n, const float *x, int incx, const float *y, int incy)

 computes the dot product of two single precision vectors. It returns the 
 dot product of the single precision vectors x and y if successful, and
 0.0f otherwise. It computes the sum for i = 0 to n - 1 of x[lx + i * 
 incx] * y[ly + i * incy], where lx = 1 if incx >= 0, else lx = 1 + (1 - n)
 *incx, and ly is defined in a similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      single precision vector with n elements
 incx   storage spacing between elements of x
 y      single precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 returns single precision dot product (zero if n <= 0)

 Reference: http://www.netlib.org/blas/sdot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has nor been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to execute on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSnrm2(int, Pointer, int)"><!-- --></A><H3>
cublasSnrm2</H3>
<PRE>
public static float <B>cublasSnrm2</B>(int&nbsp;n,
                                Pointer&nbsp;x,
                                int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 float 
 cublasSnrm2 (int n, const float *x, int incx)

 computes the Euclidean norm of the single precision n-vector x (with
 storage increment incx). This code uses a multiphase model of 
 accumulation to avoid intermediate underflow and overflow.

 Input
 -----
 n      number of elements in input vector
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns Euclidian norm (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/snrm2.f
 Reference: http://www.netlib.org/slatec/lin/snrm2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSrot(int, Pointer, int, Pointer, int, float, float)"><!-- --></A><H3>
cublasSrot</H3>
<PRE>
public static void <B>cublasSrot</B>(int&nbsp;n,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              float&nbsp;sc,
                              float&nbsp;ss)</PRE>
<DL>
<DD><pre>
 void 
 cublasSrot (int n, float *x, int incx, float *y, int incy, float sc, 
             float ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      single precision vector with n elements
 incx   storage spacing between elements of x
 y      single precision vector with n elements
 incy   storage spacing between elements of y
 sc     element of rotation matrix
 ss     element of rotation matrix

 Output
 ------
 x      rotated vector x (unchanged if n <= 0)
 y      rotated vector y (unchanged if n <= 0)

 Reference  http://www.netlib.org/blas/srot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSrotg(Pointer, Pointer, Pointer, Pointer)"><!-- --></A><H3>
cublasSrotg</H3>
<PRE>
public static void <B>cublasSrotg</B>(Pointer&nbsp;host_sa,
                               Pointer&nbsp;host_sb,
                               Pointer&nbsp;host_sc,
                               Pointer&nbsp;host_ss)</PRE>
<DL>
<DD><pre>
 void 
 cublasSrotg (float *host_sa, float *host_sb, float *host_sc, float *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).

 The quantity r = (+/-) sqrt (sa^2 + sb^2) overwrites sa in storage. The 
 value of sb is overwritten by a value z which allows sc and ss to be 
 recovered by the following algorithm:

    if z=1          set sc = 0.0 and ss = 1.0
    if abs(z) < 1   set sc = sqrt(1-z^2) and ss = z
    if abs(z) > 1   set sc = 1/z and ss = sqrt(1-sc^2)

 The function srot (n, x, incx, y, incy, sc, ss) normally is called next
 to apply the transformation to a 2 x n matrix.
 Note that is function is provided for completeness and run exclusively 
 on the Host.

 Input
 -----
 sa     single precision scalar
 sb     single precision scalar

 Output
 ------
 sa     single precision r
 sb     single precision z
 sc     single precision result
 ss     single precision result

 Reference: http://www.netlib.org/blas/srotg.f

 This function does not set any error status.
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSscal(int, float, Pointer, int)"><!-- --></A><H3>
cublasSscal</H3>
<PRE>
public static void <B>cublasSscal</B>(int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 sscal (int n, float alpha, float *x, int incx)

 replaces single precision vector x with single precision alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  single precision scalar multiplier
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      single precision result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/sscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSswap(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSswap</H3>
<PRE>
public static void <B>cublasSswap</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasSswap (int n, float *x, int incx, float *y, int incy)

 replaces single precision vector x with single precision alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  single precision scalar multiplier
 x      single precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      single precision result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/sscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCaxpy(int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCaxpy</H3>
<PRE>
public static void <B>cublasCaxpy</B>(int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasCaxpy (int n, cuComplex alpha, const cuComplex *x, int incx, 
              cuComplex *y, int incy)

 multiplies single-complex vector x by single-complex scalar alpha and adds 
 the result to single-complex vector y; that is, it overwrites single-complex
 y with single-complex alpha * x + y. For i = 0 to n - 1, it replaces 
 y[ly + i * incy] with alpha * x[lx + i * incx] + y[ly + i * incy], where 
 lx = 0 if incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a 
 similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 alpha  single-complex scalar multiplier
 x      single-complex vector with n elements
 incx   storage spacing between elements of x
 y      single-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      single-complex result (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/caxpy.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCcopy(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCcopy</H3>
<PRE>
public static void <B>cublasCcopy</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasCcopy (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 copies the single-complex vector x to the single-complex vector y. For 
 i = 0 to n-1, copies x[lx + i * incx] to y[ly + i * incy], where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a similar 
 way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      single-complex vector with n elements
 incx   storage spacing between elements of x
 y      single-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      contains single complex vector x

 Reference: http://www.netlib.org/blas/ccopy.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZcopy(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZcopy</H3>
<PRE>
public static void <B>cublasZcopy</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasZcopy (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 copies the double-complex vector x to the double-complex vector y. For 
 i = 0 to n-1, copies x[lx + i * incx] to y[ly + i * incy], where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a similar 
 way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-complex vector with n elements
 incx   storage spacing between elements of x
 y      double-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      contains double complex vector x

 Reference: http://www.netlib.org/blas/zcopy.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCscal(int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCscal</H3>
<PRE>
public static void <B>cublasCscal</B>(int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 cublasCscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  single-complex scalar multiplier
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      single-complex result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/cscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCrotg(Pointer, jcuda.jcublas.cuComplex, Pointer, Pointer)"><!-- --></A><H3>
cublasCrotg</H3>
<PRE>
public static void <B>cublasCrotg</B>(Pointer&nbsp;host_ca,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;cb,
                               Pointer&nbsp;host_sc,
                               Pointer&nbsp;host_cs)</PRE>
<DL>
<DD><pre>
 void 
 cublasCrotg (cuComplex *host_ca, cuComplex cb, float *host_sc, cuComplex *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).

 The quantity ca/cabs(ca)*norm(ca,cb) overwrites ca in storage. The 
 function crot (n, x, incx, y, incy, sc, cs) is normally called next
 to apply the transformation to a 2 x n matrix.
 Note that is function is provided for completeness and run exclusively 
 on the Host.

 Input
 -----
 ca     single-precision complex precision scalar
 cb     single-precision complex scalar

 Output
 ------
 ca     single-precision complex ca/cabs(ca)*norm(ca,cb)
 sc     single-precision cosine component of rotation matrix
 cs     single-precision complex sine component of rotation matrix

 Reference: http://www.netlib.org/blas/crotg.f

 This function does not set any error status.
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCrot(int, Pointer, int, Pointer, int, float, jcuda.jcublas.cuComplex)"><!-- --></A><H3>
cublasCrot</H3>
<PRE>
public static void <B>cublasCrot</B>(int&nbsp;n,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              float&nbsp;c,
                              <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;s)</PRE>
<DL>
<DD><pre>
 void 
 cublasCrot (int n, cuComplex *x, int incx, cuComplex *y, int incy, float sc,
             cuComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      single-precision complex vector with n elements
 incx   storage spacing between elements of x
 y      single-precision complex vector with n elements
 incy   storage spacing between elements of y
 sc     single-precision cosine component of rotation matrix
 cs     single-precision complex sine component of rotation matrix

 Output
 ------
 x      rotated single-precision complex vector x (unchanged if n <= 0)
 y      rotated single-precision complex vector y (unchanged if n <= 0)

 Reference: http://netlib.org/lapack/explore-html/crot.f.html

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCsrot(int, Pointer, int, Pointer, int, float, float)"><!-- --></A><H3>
cublasCsrot</H3>
<PRE>
public static void <B>cublasCsrot</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               float&nbsp;c,
                               float&nbsp;s)</PRE>
<DL>
<DD><pre>
 void 
 csrot (int n, cuComplex *x, int incx, cuCumplex *y, int incy, float c, 
        float s)

 multiplies a 2x2 rotation matrix ( c s) with a 2xn matrix ( transpose(x) )
                                  (-s c)                   ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      single-precision complex vector with n elements
 incx   storage spacing between elements of x
 y      single-precision complex vector with n elements
 incy   storage spacing between elements of y
 c      cosine component of rotation matrix
 s      sine component of rotation matrix

 Output
 ------
 x      rotated vector x (unchanged if n <= 0)
 y      rotated vector y (unchanged if n <= 0)

 Reference  http://www.netlib.org/blas/csrot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCsscal(int, float, Pointer, int)"><!-- --></A><H3>
cublasCsscal</H3>
<PRE>
public static void <B>cublasCsscal</B>(int&nbsp;n,
                                float&nbsp;alpha,
                                Pointer&nbsp;x,
                                int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 cublasCsscal (int n, float alpha, cuComplex *x, int incx)

 replaces single-complex vector x with single-complex alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  single precision scalar multiplier
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      single-complex result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/csscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCswap(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCswap</H3>
<PRE>
public static void <B>cublasCswap</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasCswap (int n, const cuComplex *x, int incx, cuComplex *y, int incy)

 interchanges the single-complex vector x with the single-complex vector y. 
 For i = 0 to n-1, interchanges x[lx + i * incx] with y[ly + i * incy], where
 lx = 1 if incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a 
 similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      single-complex vector with n elements
 incx   storage spacing between elements of x
 y      single-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 x      contains-single complex vector y
 y      contains-single complex vector x

 Reference: http://www.netlib.org/blas/cswap.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZswap(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZswap</H3>
<PRE>
public static void <B>cublasZswap</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasZswap (int n, const cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy)

 interchanges the double-complex vector x with the double-complex vector y. 
 For i = 0 to n-1, interchanges x[lx + i * incx] with y[ly + i * incy], where
 lx = 1 if incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a 
 similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-complex vector with n elements
 incx   storage spacing between elements of x
 y      double-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 x      contains-double complex vector y
 y      contains-double complex vector x

 Reference: http://www.netlib.org/blas/zswap.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIcamax(int, Pointer, int)"><!-- --></A><H3>
cublasIcamax</H3>
<PRE>
public static int <B>cublasIcamax</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIcamax (int n, const float *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/icamax.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIcamin(int, Pointer, int)"><!-- --></A><H3>
cublasIcamin</H3>
<PRE>
public static int <B>cublasIcamin</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIcamin (int n, const float *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in single-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: see ICAMAX.

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasScasum(int, Pointer, int)"><!-- --></A><H3>
cublasScasum</H3>
<PRE>
public static float <B>cublasScasum</B>(int&nbsp;n,
                                 Pointer&nbsp;x,
                                 int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 float 
 cublasScasum (int n, const cuDouble *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 single precision result. Note that this is not the L1 norm of the vector.
 The result is the sum from 0 to n-1 of abs(real(x[ix+i*incx])) +
 abs(imag(x(ix+i*incx))), where ix = 1 if incx <= 0, else ix = 1+(1-n)*incx.
 
 Input
 -----
 n      number of elements in input vector
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the single precision sum of absolute values of real and imaginary
 parts (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/scasum.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasScnrm2(int, Pointer, int)"><!-- --></A><H3>
cublasScnrm2</H3>
<PRE>
public static float <B>cublasScnrm2</B>(int&nbsp;n,
                                 Pointer&nbsp;x,
                                 int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 float 
 cublasScnrm2 (int n, const cuComplex *x, int incx)

 computes the Euclidean norm of the single-complex n-vector x. This code 
 uses simple scaling to avoid intermediate underflow and overflow.

 Input
 -----
 n      number of elements in input vector
 x      single-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns Euclidian norm (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/scnrm2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZaxpy(int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZaxpy</H3>
<PRE>
public static void <B>cublasZaxpy</B>(int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasZaxpy (int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              cuDoubleComplex *y, int incy)

 multiplies double-complex vector x by double-complex scalar alpha and adds 
 the result to double-complex vector y; that is, it overwrites double-complex
 y with double-complex alpha * x + y. For i = 0 to n - 1, it replaces 
 y[ly + i * incy] with alpha * x[lx + i * incx] + y[ly + i * incy], where 
 lx = 0 if incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a 
 similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 alpha  double-complex scalar multiplier
 x      double-complex vector with n elements
 incx   storage spacing between elements of x
 y      double-complex vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      double-complex result (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/zaxpy.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZscal(int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZscal</H3>
<PRE>
public static void <B>cublasZscal</B>(int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 cublasZscal (int n, cuComplex alpha, cuComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  double-complex scalar multiplier
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      double-complex result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/zscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZdscal(int, double, Pointer, int)"><!-- --></A><H3>
cublasZdscal</H3>
<PRE>
public static void <B>cublasZdscal</B>(int&nbsp;n,
                                double&nbsp;alpha,
                                Pointer&nbsp;x,
                                int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 cublasZdscal (int n, double alpha, cuDoubleComplex *x, int incx)

 replaces double-complex vector x with double-complex alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  double precision scalar multiplier
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      double-complex result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/zdscal.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDznrm2(int, Pointer, int)"><!-- --></A><H3>
cublasDznrm2</H3>
<PRE>
public static double <B>cublasDznrm2</B>(int&nbsp;n,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 double 
 cublasDznrm2 (int n, const cuDoubleComplex *x, int incx)

 computes the Euclidean norm of the double precision complex n-vector x. This code 
 uses simple scaling to avoid intermediate underflow and overflow.

 Input
 -----
 n      number of elements in input vector
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns Euclidian norm (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/dznrm2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZrotg(Pointer, jcuda.jcublas.cuDoubleComplex, Pointer, Pointer)"><!-- --></A><H3>
cublasZrotg</H3>
<PRE>
public static void <B>cublasZrotg</B>(Pointer&nbsp;host_ca,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;cb,
                               Pointer&nbsp;host_sc,
                               Pointer&nbsp;host_cs)</PRE>
<DL>
<DD><pre>
 void 
 cublasZrotg (cuDoubleComplex *host_ca, cuDoubleComplex cb, double *host_sc, double *host_cs)

 constructs the complex Givens tranformation

        ( sc  cs )
    G = (        ) ,  sc^2 + cabs(cs)^2 = 1,
        (-cs  sc )
 
 which zeros the second entry of the complex 2-vector transpose(ca, cb).

 The quantity ca/cabs(ca)*norm(ca,cb) overwrites ca in storage. The 
 function crot (n, x, incx, y, incy, sc, cs) is normally called next
 to apply the transformation to a 2 x n matrix.
 Note that is function is provided for completeness and run exclusively 
 on the Host. 

 Input
 -----
 ca     double-precision complex precision scalar
 cb     double-precision complex scalar

 Output
 ------
 ca     double-precision complex ca/cabs(ca)*norm(ca,cb)
 sc     double-precision cosine component of rotation matrix
 cs     double-precision complex sine component of rotation matrix

 Reference: http://www.netlib.org/blas/zrotg.f

 This function does not set any error status.
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZrot(int, Pointer, int, Pointer, int, double, jcuda.jcublas.cuDoubleComplex)"><!-- --></A><H3>
cublasZrot</H3>
<PRE>
public static void <B>cublasZrot</B>(int&nbsp;n,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              double&nbsp;sc,
                              <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;cs)</PRE>
<DL>
<DD><pre>
 cublasZrot (int n, cuDoubleComplex *x, int incx, cuDoubleComplex *y, int incy, double sc,
             cuDoubleComplex cs)

 multiplies a 2x2 matrix ( sc       cs) with the 2xn matrix ( transpose(x) )
                         (-conj(cs) sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-precision complex vector with n elements
 incx   storage spacing between elements of x
 y      double-precision complex vector with n elements
 incy   storage spacing between elements of y
 sc     double-precision cosine component of rotation matrix
 cs     double-precision complex sine component of rotation matrix

 Output
 ------
 x      rotated double-precision complex vector x (unchanged if n <= 0)
 y      rotated double-precision complex vector y (unchanged if n <= 0)

 Reference: http://netlib.org/lapack/explore-html/zrot.f.html

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support    
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZdrot(int, Pointer, int, Pointer, int, double, double)"><!-- --></A><H3>
cublasZdrot</H3>
<PRE>
public static void <B>cublasZdrot</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               double&nbsp;c,
                               double&nbsp;s)</PRE>
<DL>
<DD><pre>
 void 
 zdrot (int n, cuDoubleComplex *x, int incx, cuCumplex *y, int incy, double c, 
        double s)

 multiplies a 2x2 matrix ( c s) with the 2xn matrix ( transpose(x) )
                         (-s c)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-precision complex vector with n elements
 incx   storage spacing between elements of x
 y      double-precision complex vector with n elements
 incy   storage spacing between elements of y
 c      cosine component of rotation matrix
 s      sine component of rotation matrix

 Output
 ------
 x      rotated vector x (unchanged if n <= 0)
 y      rotated vector y (unchanged if n <= 0)

 Reference  http://www.netlib.org/blas/zdrot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support    
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIzamax(int, Pointer, int)"><!-- --></A><H3>
cublasIzamax</H3>
<PRE>
public static int <B>cublasIzamax</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIzamax (int n, const double *x, int incx)

 finds the smallest index of the element having maximum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that maximizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/izamax.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIzamin(int, Pointer, int)"><!-- --></A><H3>
cublasIzamin</H3>
<PRE>
public static int <B>cublasIzamin</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 cublasIzamin (int n, const cuDoubleComplex *x, int incx)

 finds the smallest index of the element having minimum absolute value
 in double-complex vector x; that is, the result is the first i, i = 0 
 to n - 1 that minimizes abs(real(x[1+i*incx]))+abs(imag(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: Analogous to IZAMAX, see there.

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDzasum(int, Pointer, int)"><!-- --></A><H3>
cublasDzasum</H3>
<PRE>
public static double <B>cublasDzasum</B>(int&nbsp;n,
                                  Pointer&nbsp;x,
                                  int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 double 
 cublasDzasum (int n, const cuDoubleComplex *x, int incx)

 takes the sum of the absolute values of a complex vector and returns a
 double precision result. Note that this is not the L1 norm of the vector.
 The result is the sum from 0 to n-1 of abs(real(x[ix+i*incx])) +
 abs(imag(x(ix+i*incx))), where ix = 1 if incx <= 0, else ix = 1+(1-n)*incx.
 
 Input
 -----
 n      number of elements in input vector
 x      double-complex vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the double precision sum of absolute values of real and imaginary
 parts (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/dzasum.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSgbmv(char, int, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSgbmv</H3>
<PRE>
public static void <B>cublasSgbmv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;kl,
                               int&nbsp;ku,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               float&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasSgbmv (char trans, int m, int n, int kl, int ku, float alpha,
              const float *A, int lda, const float *x, int incx, float beta,
              float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision scalars. x and y are single precision
 vectors. A is an m by n band matrix consisting of single precision elements
 with kl sub-diagonals and ku super-diagonals.

 Input
 -----
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T', 
        't', 'C', or 'c', op(A) = transpose(A)
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least
        zero.
 kl     specifies the number of sub-diagonals of matrix A. It must be at 
        least zero.
 ku     specifies the number of super-diagonals of matrix A. It must be at 
        least zero.
 alpha  single precision scalar multiplier applied to op(A).
 A      single precision array of dimensions (lda, n). The leading
        (kl + ku + 1) x n part of the array A must contain the band matrix A,
        supplied column by column, with the leading diagonal of the matrix 
        in row (ku + 1) of the array, the first super-diagonal starting at 
        position 2 in row ku, the first sub-diagonal starting at position 1
        in row (ku + 2), and so on. Elements in the array A that do not 
        correspond to elements in the band matrix (such as the top left 
        ku x ku triangle) are not referenced.
 lda    leading dimension of A. lda must be at least (kl + ku + 1).
 x      single precision array of length at least (1+(n-1)*abs(incx)) when 
        trans == 'N' or 'n' and at least (1+(m-1)*abs(incx)) otherwise.
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      single precision array of length at least (1+(m-1)*abs(incy)) when 
        trans == 'N' or 'n' and at least (1+(n-1)*abs(incy)) otherwise. If 
        beta is zero, y is not read.
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*op(A)*x + beta*y

 Reference: http://www.netlib.org/blas/sgbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n, kl, or ku < 0; if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSgemv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSgemv</H3>
<PRE>
public static void <B>cublasSgemv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               float&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 cublasSgemv (char trans, int m, int n, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements. Matrix A is stored in column major format, and lda is the leading
 dimension of the two-dimensional array in which A is stored.

 Input
 -----
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If trans =
        trans = 't', 'T', 'c', or 'C', op(A) = transpose(A)
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least 
        zero.
 alpha  single precision scalar multiplier applied to op(A).
 A      single precision array of dimensions (lda, n) if trans = 'n' or 
        'N'), and of dimensions (lda, m) otherwise. lda must be at least 
        max(1, m) and at least max(1, n) otherwise.
 lda    leading dimension of two-dimensional array used to store matrix A
 x      single precision array of length at least (1 + (n - 1) * abs(incx))
        when trans = 'N' or 'n' and at least (1 + (m - 1) * abs(incx)) 
        otherwise.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.
 beta   single precision scalar multiplier applied to vector y. If beta 
        is zero, y is not read.
 y      single precision array of length at least (1 + (m - 1) * abs(incy))
        when trans = 'N' or 'n' and at least (1 + (n - 1) * abs(incy)) 
        otherwise.
 incy   specifies the storage spacing between elements of x. incx must not
        be zero.

 Output
 ------
 y      updated according to alpha * op(A) * x + beta * y

 Reference: http://www.netlib.org/blas/sgemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSger(int, int, float, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSger</H3>
<PRE>
public static void <B>cublasSger</B>(int&nbsp;m,
                              int&nbsp;n,
                              float&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasSger (int m, int n, float alpha, const float *x, int incx, 
             const float *y, int incy, float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision scalar, x is an m element single 
 precision vector, y is an n element single precision vector, and A 
 is an m by n matrix consisting of single precision elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.
 
 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least 
        zero.
 n      specifies the number of columns of the matrix A. It must be at 
        least zero.
 alpha  single precision scalar multiplier applied to x * transpose(y)
 x      single precision array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      single precision array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not 
        be zero.
 A      single precision array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * transpose(y) + A

 Reference: http://www.netlib.org/blas/sger.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsbmv(char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSsbmv</H3>
<PRE>
public static void <B>cublasSsbmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               int&nbsp;k,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               float&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsbmv (char uplo, int n, int k, float alpha, const float *A, int lda,
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision scalars. x and y are single precision
 vectors with n elements. A is an n x n symmetric band matrix consisting 
 of single precision elements, with k super-diagonals and the same number
 of sub-diagonals.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the symmetric
        band matrix A is being supplied. If uplo == 'U' or 'u', the upper 
        triangular part is being supplied. If uplo == 'L' or 'l', the lower 
        triangular part is being supplied.
 n      specifies the number of rows and the number of columns of the
        symmetric matrix A. n must be at least zero.
 k      specifies the number of super-diagonals of matrix A. Since the matrix
        is symmetric, this is also the number of sub-diagonals. k must be at
        least zero.
 alpha  single precision scalar multiplier applied to A*x.
 A      single precision array of dimensions (lda, n). When uplo == 'U' or 
        'u', the leading (k + 1) x n part of array A must contain the upper
        triangular band of the symmetric matrix, supplied column by column,
        with the leading diagonal of the matrix in row (k+1) of the array,
        the first super-diagonal starting at position 2 in row k, and so on.
        The top left k x k triangle of the array A is not referenced. When
        uplo == 'L' or 'l', the leading (k + 1) x n part of the array A must
        contain the lower triangular band part of the symmetric matrix, 
        supplied column by column, with the leading diagonal of the matrix in
        row 1 of the array, the first sub-diagonal starting at position 1 in
        row 2, and so on. The bottom right k x k triangle of the array A is
        not referenced.
 lda    leading dimension of A. lda must be at least (k + 1).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      single precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read.
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/ssbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_INVALID_VALUE    if k or n < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSspmv(char, int, float, Pointer, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSspmv</H3>
<PRE>
public static void <B>cublasSspmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               float&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasSspmv (char uplo, int n, float alpha, const float *AP, const float *x,
              int incx, float beta, float *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors with n elements. A is a symmetric n x n matrix 
 consisting of single precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision scalar multiplier applied to A*x.
 AP     single precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision scalar multiplier applied to vector y;
 y      single precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/sspmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSspr(char, int, float, Pointer, int, Pointer)"><!-- --></A><H3>
cublasSspr</H3>
<PRE>
public static void <B>cublasSspr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              float&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre>
 void 
 cublasSspr (char uplo, int n, float alpha, const float *x, int incx, 
             float *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a single precision scalar and x is an n element single 
 precision vector. A is a symmetric n x n matrix consisting of single 
 precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision scalar multiplier applied to x * transpose(x).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 AP     single precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].

 Output
 ------
 A      updated according to A = alpha * x * transpose(x) + A

 Reference: http://www.netlib.org/blas/sspr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSspr2(char, int, float, Pointer, int, Pointer, int, Pointer)"><!-- --></A><H3>
cublasSspr2</H3>
<PRE>
public static void <B>cublasSspr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre> 
 void 
 cublasSspr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, and x and y are n element single 
 precision vectors. A is a symmetric n x n matrix consisting of single 
 precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision scalar multiplier applied to x * transpose(y) + 
        y * transpose(x).
 x      single precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      single precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 AP     single precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].

 Output
 ------
 A      updated according to A = alpha*x*transpose(y)+alpha*y*transpose(x)+A

 Reference: http://www.netlib.org/blas/sspr2.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsymv(char, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSsymv</H3>
<PRE>
public static void <B>cublasSsymv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               float&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsymv (char uplo, int n, float alpha, const float *A, int lda, 
              const float *x, int incx, float beta, float *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision scalars, and x and y are single 
 precision vectors, each with n elements. A is a symmetric n x n matrix 
 consisting of single precision elements that is stored in either upper or 
 lower storage mode.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the array A 
        is to be referenced. If uplo == 'U' or 'u', the symmetric matrix A 
        is stored in upper storage mode, i.e. only the upper triangular part
        of A is to be referenced while the lower triangular part of A is to 
        be inferred. If uplo == 'L' or 'l', the symmetric matrix A is stored
        in lower storage mode, i.e. only the lower triangular part of A is 
        to be referenced while the upper triangular part of A is to be 
        inferred.
 n      specifies the number of rows and the number of columns of the 
        symmetric matrix A. n must be at least zero.
 alpha  single precision scalar multiplier applied to A*x.
 A      single precision array of dimensions (lda, n). If uplo == 'U' or 'u',
        the leading n x n upper triangular part of the array A must contain
        the upper triangular part of the symmetric matrix and the strictly
        lower triangular part of A is not referenced. If uplo == 'L' or 'l',
        the leading n x n lower triangular part of the array A must contain
        the lower triangular part of the symmetric matrix and the strictly
        upper triangular part of A is not referenced. 
 lda    leading dimension of A. It must be at least max (1, n).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision scalar multiplier applied to vector y.
 y      single precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/ssymv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsyr(char, int, float, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSsyr</H3>
<PRE>
public static void <B>cublasSsyr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              float&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsyr (char uplo, int n, float alpha, const float *x, int incx,
             float *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a single precision scalar, x is an n element single 
 precision vector and A is an n x n symmetric matrix consisting of 
 single precision elements. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array 
 containing A.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or 
        the lower triangular part of array A. If uplo = 'U' or 'u',
        then only the upper triangular part of A may be referenced.
        If uplo = 'L' or 'l', then only the lower triangular part of
        A may be referenced.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0.
 alpha  single precision scalar multiplier applied to x * transpose(x)
 x      single precision array of length at least (1 + (n - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must 
        not be zero.
 A      single precision array of dimensions (lda, n). If uplo = 'U' or 
        'u', then A must contain the upper triangular part of a symmetric 
        matrix, and the strictly lower triangular part is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part 
        of a symmetric matrix, and the strictly upper triangular part is 
        not referenced.
 lda    leading dimension of the two-dimensional array containing A. lda
        must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha * x * transpose(x) + A

 Reference: http://www.netlib.org/blas/ssyr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsyr2(char, int, float, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasSsyr2</H3>
<PRE>
public static void <B>cublasSsyr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsyr2 (char uplo, int n, float alpha, const float *x, int incx, 
              const float *y, int incy, float *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a single precision scalar, x and y are n element single 
 precision vector and A is an n by n symmetric matrix consisting of single 
 precision elements.
 
 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision scalar multiplier applied to x * transpose(y) + 
        y * transpose(x).
 x      single precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      single precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 A      single precision array of dimensions (lda, n). If uplo == 'U' or 'u',
        then A must contains the upper triangular part of a symmetric matrix,
        and the strictly lower triangular parts is not referenced. If uplo ==
        'L' or 'l', then A contains the lower triangular part of a symmetric 
        matrix, and the strictly upper triangular part is not referenced.
 lda    leading dimension of A. It must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha*x*transpose(y)+alpha*y*transpose(x)+A

 Reference: http://www.netlib.org/blas/ssyr2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStbmv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStbmv</H3>
<PRE>
public static void <B>cublasStbmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasStbmv (char uplo, char trans, char diag, int n, int k, const float *A,
              int lda, float *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A
 or op(A) = transpose(A). x is an n-element single precision vector, and A is
 an n x n, unit or non-unit upper or lower triangular band matrix consisting
 of single precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular band
        matrix. If uplo == 'U' or 'u', A is an upper triangular band matrix.
        If uplo == 'L' or 'l', A is a lower triangular band matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A).
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero. In the current implementation n must not exceed 4070.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or 
        'u', k specifies the number of super-diagonals. If uplo == 'L' or 
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      single precision array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper 
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first 
        super-diagonal starting at position 2 in row k, and so on. The top
        left k x k triangle of the array A is not referenced. If uplo == 'L'
        or 'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first 
        sub-diagonal startingat position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 lda    is the leading dimension of A. It must be at least (k + 1).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x

 Reference: http://www.netlib.org/blas/stbmv.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, k < 0, or incx == 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStbsv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStbsv</H3>
<PRE>
public static void <B>cublasStbsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void cublasStbsv (char uplo, char trans, char diag, int n, int k,
                   const float *A, int lda, float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n-element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals. No test for singularity or near-singularity is included in this
 function. Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular band 
        matrix as follows: If uplo == 'U' or 'u', A is an upper triangular
        band matrix. If uplo == 'L' or 'l', A is a lower triangular band
        matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or
        'u', k specifies the number of super-diagonals. If uplo == 'L' or
        'l', k specifies the number of sub-diagonals. k must be at least
        zero.
 A      single precision array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first super-
        diagonal starting at position 2 in row k, and so on. The top left 
        k x k triangle of the array A is not referenced. If uplo == 'L' or 
        'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first
        sub-diagonal starting at position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 x      single precision array of length at least (1 + (n - 1) * abs(incx)). 
        On entry, x contains the n-element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   storage spacing between elements of x. incx must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/stbsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0, n < 0 or n > 4070
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStpmv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasStpmv</H3>
<PRE>
public static void <B>cublasStpmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasStpmv (char uplo, char trans, char diag, int n, const float *AP, 
              float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element single precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of single precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo == 'U' or 'u', then A is an upper triangular matrix.
        If uplo == 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A)
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero.
 AP     single precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored in AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/stpmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStpsv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasStpsv</H3>
<PRE>
public static void <B>cublasStpsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasStpsv (char uplo, char trans, char diag, int n, const float *AP,
              float *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix. No test for
 singularity or near-singularity is included in this function. Such tests 
 must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular matrix
        as follows: If uplo == 'U' or 'u', A is an upper triangluar matrix.
        If uplo == 'L' or 'l', A is a lower triangular matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero. In the current implementation n must not exceed 4070.
 AP     single precision array with at least ((n*(n+1))/2) elements. If uplo
        == 'U' or 'u', the array AP contains the upper triangular matrix A,
        packed sequentially, column by column; that is, if i <= j, then 
        A[i,j] is stored is AP[i+(j*(j+1)/2)]. If uplo == 'L' or 'L', the 
        array AP contains the lower triangular matrix A, packed sequentially,
        column by column; that is, if i >= j, then A[i,j] is stored in 
        AP[i+((2*n-j+1)*j)/2]. When diag = 'U' or 'u', the diagonal elements
        of A are not referenced and are assumed to be unity.
 x      single precision array of length at least (1 + (n - 1) * abs(incx)). 
        On entry, x contains the n-element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/stpsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0, n < 0, or n > 4070
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStrmv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStrmv</H3>
<PRE>
public static void <B>cublasStrmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasStrmv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular 
        matrix. If uplo = 'U' or 'u', then A is an upper triangular matrix. 
        If uplo = 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa = 'N' or 'n', op(A) = A. If trans = 'T', 
        't', 'C', or 'c', op(A) = transpose(A)
 diag   specifies whether or not matrix A is unit triangular. If diag = 'U' 
        or 'u', A is assumed to be unit triangular. If diag = 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero.
 A      single precision array of dimension (lda, n). If uplo = 'U' or 'u', 
        the leading n x n upper triangular part of the array A must contain 
        the upper triangular matrix and the strictly lower triangular part 
        of A is not referenced. If uplo = 'L' or 'l', the leading n x n lower
        triangular part of the array A must contain the lower triangular 
        matrix and the strictly upper triangular part of A is not referenced.
        When diag = 'U' or 'u', the diagonal elements of A are not referenced
        either, but are are assumed to be unity.
 lda    is the leading dimension of A. It must be at least max (1, n).
 x      single precision array of length at least (1 + (n - 1) * abs(incx) ).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/strmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStrsv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStrsv</H3>
<PRE>
public static void <B>cublasStrsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasStrsv (char uplo, char trans, char diag, int n, const float *A,
              int lda, float *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are single precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array containing
 A.

 No test for singularity or near-singularity is included in this function. 
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the 
        lower triangular part of array A. If uplo = 'U' or 'u', then only 
        the upper triangular part of A may be referenced. If uplo = 'L' or 
        'l', then only the lower triangular part of A may be referenced.
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If transa = 't',
        'T', 'c', or 'C', op(A) = transpose(A)
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If 
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0. 
 A      is a single precision array of dimensions (lda, n). If uplo = 'U' 
        or 'u', then A must contains the upper triangular part of a symmetric
        matrix, and the strictly lower triangular parts is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part of 
        a symmetric matrix, and the strictly upper triangular part is not 
        referenced. 
 lda    is the leading dimension of the two-dimensional array containing A.
        lda must be at least max(1, n).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the n element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/strsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtrmv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtrmv</H3>
<PRE>
public static void <B>cublasZtrmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtrmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)). 
 x is an n-element double precision complex vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of double precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular 
        matrix. If uplo = 'U' or 'u', then A is an upper triangular matrix. 
        If uplo = 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If trans = 'n' or 'N', op(A) = A. If trans = 't' or
        'T', op(A) = transpose(A).  If trans = 'c' or 'C', op(A) =
        conjugate(transpose(A)).
 diag   specifies whether or not matrix A is unit triangular. If diag = 'U' 
        or 'u', A is assumed to be unit triangular. If diag = 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero.
 A      double precision array of dimension (lda, n). If uplo = 'U' or 'u', 
        the leading n x n upper triangular part of the array A must contain 
        the upper triangular matrix and the strictly lower triangular part 
        of A is not referenced. If uplo = 'L' or 'l', the leading n x n lower
        triangular part of the array A must contain the lower triangular 
        matrix and the strictly upper triangular part of A is not referenced.
        When diag = 'U' or 'u', the diagonal elements of A are not referenced
        either, but are are assumed to be unity.
 lda    is the leading dimension of A. It must be at least max (1, n).
 x      double precision array of length at least (1 + (n - 1) * abs(incx) ).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/ztrmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZgbmv(char, int, int, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZgbmv</H3>
<PRE>
public static void <B>cublasZgbmv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;kl,
                               int&nbsp;ku,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasZgbmv (char trans, int m, int n, int kl, int ku, cuDoubleComplex alpha,
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *x, int incx, cuDoubleComplex beta,
              cuDoubleComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors. A is an m by n band matrix consisting of double precision complex elements
 with kl sub-diagonals and ku super-diagonals.

 Input
 -----
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T', 
        or 't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)).
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least
        zero.
 kl     specifies the number of sub-diagonals of matrix A. It must be at 
        least zero.
 ku     specifies the number of super-diagonals of matrix A. It must be at
        least zero.
 alpha  double precision complex scalar multiplier applied to op(A).
 A      double precision complex array of dimensions (lda, n). The leading
        (kl + ku + 1) x n part of the array A must contain the band matrix A,
        supplied column by column, with the leading diagonal of the matrix 
        in row (ku + 1) of the array, the first super-diagonal starting at 
        position 2 in row ku, the first sub-diagonal starting at position 1
        in row (ku + 2), and so on. Elements in the array A that do not 
        correspond to elements in the band matrix (such as the top left 
        ku x ku triangle) are not referenced.
 lda    leading dimension of A. lda must be at least (kl + ku + 1).
 x      double precision complex array of length at least (1+(n-1)*abs(incx)) when 
        trans == 'N' or 'n' and at least (1+(m-1)*abs(incx)) otherwise.
 incx   specifies the increment for the elements of x. incx must not be zero.
 beta   double precision complex scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      double precision complex array of length at least (1+(m-1)*abs(incy)) when 
        trans == 'N' or 'n' and at least (1+(n-1)*abs(incy)) otherwise. If 
        beta is zero, y is not read.
 incy   On entry, incy specifies the increment for the elements of y. incy 
        must not be zero.

 Output
 ------
 y      updated according to y = alpha*op(A)*x + beta*y

 Reference: http://www.netlib.org/blas/zgbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtbmv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtbmv</H3>
<PRE>
public static void <B>cublasZtbmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtbmv (char uplo, char trans, char diag, int n, int k, const cuDoubleComplex *A,
              int lda, cuDoubleComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of double precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular band
        matrix. If uplo == 'U' or 'u', A is an upper triangular band matrix.
        If uplo == 'L' or 'l', A is a lower triangular band matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        or 't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)).
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or 
        'u', k specifies the number of super-diagonals. If uplo == 'L' or 
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      double precision complex array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper 
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first 
        super-diagonal starting at position 2 in row k, and so on. The top
        left k x k triangle of the array A is not referenced. If uplo == 'L'
        or 'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first 
        sub-diagonal startingat position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 lda    is the leading dimension of A. It must be at least (k + 1).
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x

 Reference: http://www.netlib.org/blas/ztbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n or k < 0, or if incx == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtbsv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtbsv</H3>
<PRE>
public static void <B>cublasZtbsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void cublasZtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuDoubleComplex *A, int lda, cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
 b and x are n element vectors, and A is an n x n unit or non-unit,
 upper or lower triangular band matrix with k + 1 diagonals. No test
 for singularity or near-singularity is included in this function.
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular band 
        matrix as follows: If uplo == 'U' or 'u', A is an upper triangular
        band matrix. If uplo == 'L' or 'l', A is a lower triangular band
        matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)). 
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or
        'u', k specifies the number of super-diagonals. If uplo == 'L' or
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      double precision complex array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first super-
        diagonal starting at position 2 in row k, and so on. The top left 
        k x k triangle of the array A is not referenced. If uplo == 'L' or 
        'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first
        sub-diagonal starting at position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 x      double precision complex array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ztbsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0, n < 0 or n > 1016
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhemv(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZhemv</H3>
<PRE>
public static void <B>cublasZhemv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasZhemv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, 
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors, each with n elements. A is a hermitian n x n matrix 
 consisting of double precision complex elements that is stored in either upper or 
 lower storage mode.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the array A 
        is to be referenced. If uplo == 'U' or 'u', the hermitian matrix A 
        is stored in upper storage mode, i.e. only the upper triangular part
        of A is to be referenced while the lower triangular part of A is to 
        be inferred. If uplo == 'L' or 'l', the hermitian matrix A is stored
        in lower storage mode, i.e. only the lower triangular part of A is 
        to be referenced while the upper triangular part of A is to be 
        inferred.
 n      specifies the number of rows and the number of columns of the 
        hermitian matrix A. n must be at least zero.
 alpha  double precision complex scalar multiplier applied to A*x.
 A      double precision complex array of dimensions (lda, n). If uplo == 'U' or 'u',
        the leading n x n upper triangular part of the array A must contain
        the upper triangular part of the hermitian matrix and the strictly
        lower triangular part of A is not referenced. If uplo == 'L' or 'l',
        the leading n x n lower triangular part of the array A must contain
        the lower triangular part of the hermitian matrix and the strictly
        upper triangular part of A is not referenced. The imaginary parts
        of the diagonal elements need not be set, they are assumed to be zero. 
 lda    leading dimension of A. It must be at least max (1, n).
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision complex scalar multiplier applied to vector y.
 y      double precision complex array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/zhemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhpmv(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZhpmv</H3>
<PRE>
public static void <B>cublasZhpmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasZhpmv (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *AP, const cuDoubleComplex *x,
              int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision complex scalars, and x and y are double 
 precision complex vectors with n elements. A is an hermitian n x n matrix 
 consisting of double precision complex elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision complex scalar multiplier applied to A*x.
 AP     double precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
        The imaginary parts of the diagonal elements need not be set, they
        are assumed to be zero. 
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision complex scalar multiplier applied to vector y;
 y      double precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/zhpmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZgemv(char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZgemv</H3>
<PRE>
public static void <B>cublasZgemv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 cublasZgemv (char trans, int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements. Matrix A is stored in column major format, and lda is the leading
 dimension of the two-dimensional array in which A is stored.

 Input
 -----
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If trans =
        trans = 't', 'T', 'c', or 'C', op(A) = transpose(A)
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least 
        zero.
 alpha  double precision scalar multiplier applied to op(A).
 A      double precision array of dimensions (lda, n) if trans = 'n' or 
        'N'), and of dimensions (lda, m) otherwise. lda must be at least 
        max(1, m) and at least max(1, n) otherwise.
 lda    leading dimension of two-dimensional array used to store matrix A
 x      double precision array of length at least (1 + (n - 1) * abs(incx))
        when trans = 'N' or 'n' and at least (1 + (m - 1) * abs(incx)) 
        otherwise.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.
 beta   double precision scalar multiplier applied to vector y. If beta 
        is zero, y is not read.
 y      double precision array of length at least (1 + (m - 1) * abs(incy))
        when trans = 'N' or 'n' and at least (1 + (n - 1) * abs(incy)) 
        otherwise.
 incy   specifies the storage spacing between elements of x. incx must not
        be zero.

 Output
 ------
 y      updated according to alpha * op(A) * x + beta * y

 Reference: http://www.netlib.org/blas/zgemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtpmv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasZtpmv</H3>
<PRE>
public static void <B>cublasZtpmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtpmv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 double precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of double precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo == 'U' or 'u', then A is an upper triangular matrix.
        If uplo == 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        or 't', op(A) = transpose(A). If trans == 'C' or 'c', 
        op(A) = conjugate(transpose(A)).

 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero. In the current implementation n must not exceed 4070.
 AP     double precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored in AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/ztpmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or n < 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtpsv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasZtpsv</H3>
<PRE>
public static void <B>cublasZtpsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtpsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *AP, 
              cuDoubleComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix. No test for singularity or near-singularity
 is included in this routine. Such tests must be performed before calling this routine.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular matrix
        as follows: If uplo == 'U' or 'u', A is an upper triangluar matrix.
        If uplo == 'L' or 'l', A is a lower triangular matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T'
        or 't', op(A) = transpose(A). If trans == 'C' or 'c', op(A) = 
        conjugate(transpose(A)).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 AP     double precision complex array with at least ((n*(n+1))/2) elements.
        If uplo == 'U' or 'u', the array AP contains the upper triangular
        matrix A, packed sequentially, column by column; that is, if i <= j, then 
        A[i,j] is stored is AP[i+(j*(j+1)/2)]. If uplo == 'L' or 'L', the 
        array AP contains the lower triangular matrix A, packed sequentially,
        column by column; that is, if i >= j, then A[i,j] is stored in 
        AP[i+((2*n-j+1)*j)/2]. When diag = 'U' or 'u', the diagonal elements
        of A are not referenced and are assumed to be unity.
 x      double precision complex array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ztpsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0 or n > 2035
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support    
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCgemv(char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCgemv</H3>
<PRE>
public static void <B>cublasCgemv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 cublasCgemv (char trans, int m, int n, cuComplex alpha, const cuComplex *A, 
              int lda, const cuComplex *x, int incx, cuComplex beta, cuComplex *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 where alpha and beta are single precision scalars, x and y are single 
 precision vectors, and A is an m x n matrix consisting of single precision
 elements. Matrix A is stored in column major format, and lda is the leading
 dimension of the two-dimensional array in which A is stored.

 Input
 -----
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If trans =
        trans = 't' or 'T', op(A) = transpose(A). If trans = 'c' or 'C', 
        op(A) = conjugate(transpose(A))
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least 
        zero.
 alpha  single precision scalar multiplier applied to op(A).
 A      single precision array of dimensions (lda, n) if trans = 'n' or 
        'N'), and of dimensions (lda, m) otherwise. lda must be at least 
        max(1, m) and at least max(1, n) otherwise.
 lda    leading dimension of two-dimensional array used to store matrix A
 x      single precision array of length at least (1 + (n - 1) * abs(incx))
        when trans = 'N' or 'n' and at least (1 + (m - 1) * abs(incx)) 
        otherwise.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.
 beta   single precision scalar multiplier applied to vector y. If beta 
        is zero, y is not read.
 y      single precision array of length at least (1 + (m - 1) * abs(incy))
        when trans = 'N' or 'n' and at least (1 + (n - 1) * abs(incy)) 
        otherwise.
 incy   specifies the storage spacing between elements of y. incy must not
        be zero.

 Output
 ------
 y      updated according to alpha * op(A) * x + beta * y

 Reference: http://www.netlib.org/blas/cgemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCgbmv(char, int, int, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCgbmv</H3>
<PRE>
public static void <B>cublasCgbmv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;kl,
                               int&nbsp;ku,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasCgbmv (char trans, int m, int n, int kl, int ku, cuComplex alpha,
              const cuComplex *A, int lda, const cuComplex *x, int incx, cuComplex beta,
              cuComplex *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors. A is an m by n band matrix consisting of single precision complex elements
 with kl sub-diagonals and ku super-diagonals.

 Input
 -----
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T', 
        or 't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)).
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least
        zero.
 kl     specifies the number of sub-diagonals of matrix A. It must be at 
        least zero.
 ku     specifies the number of super-diagonals of matrix A. It must be at
        least zero.
 alpha  single precision complex scalar multiplier applied to op(A).
 A      single precision complex array of dimensions (lda, n). The leading
        (kl + ku + 1) x n part of the array A must contain the band matrix A,
        supplied column by column, with the leading diagonal of the matrix 
        in row (ku + 1) of the array, the first super-diagonal starting at 
        position 2 in row ku, the first sub-diagonal starting at position 1
        in row (ku + 2), and so on. Elements in the array A that do not 
        correspond to elements in the band matrix (such as the top left 
        ku x ku triangle) are not referenced.
 lda    leading dimension of A. lda must be at least (kl + ku + 1).
 x      single precision complex array of length at least (1+(n-1)*abs(incx)) when 
        trans == 'N' or 'n' and at least (1+(m-1)*abs(incx)) otherwise.
 incx   specifies the increment for the elements of x. incx must not be zero.
 beta   single precision complex scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      single precision complex array of length at least (1+(m-1)*abs(incy)) when 
        trans == 'N' or 'n' and at least (1+(n-1)*abs(incy)) otherwise. If 
        beta is zero, y is not read.
 incy   On entry, incy specifies the increment for the elements of y. incy 
        must not be zero.

 Output
 ------
 y      updated according to y = alpha*op(A)*x + beta*y

 Reference: http://www.netlib.org/blas/cgbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasChemv(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasChemv</H3>
<PRE>
public static void <B>cublasChemv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasChemv (char uplo, int n, cuComplex alpha, const cuComplex *A, int lda, 
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are single precision complex scalars, and x and y are single 
 precision complex vectors, each with n elements. A is a hermitian n x n matrix 
 consisting of single precision complex elements that is stored in either upper or 
 lower storage mode.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the array A 
        is to be referenced. If uplo == 'U' or 'u', the hermitian matrix A 
        is stored in upper storage mode, i.e. only the upper triangular part
        of A is to be referenced while the lower triangular part of A is to 
        be inferred. If uplo == 'L' or 'l', the hermitian matrix A is stored
        in lower storage mode, i.e. only the lower triangular part of A is 
        to be referenced while the upper triangular part of A is to be 
        inferred.
 n      specifies the number of rows and the number of columns of the 
        hermitian matrix A. n must be at least zero.
 alpha  single precision complex scalar multiplier applied to A*x.
 A      single precision complex array of dimensions (lda, n). If uplo == 'U' or 'u',
        the leading n x n upper triangular part of the array A must contain
        the upper triangular part of the hermitian matrix and the strictly
        lower triangular part of A is not referenced. If uplo == 'L' or 'l',
        the leading n x n lower triangular part of the array A must contain
        the lower triangular part of the hermitian matrix and the strictly
        upper triangular part of A is not referenced. The imaginary parts
        of the diagonal elements need not be set, they are assumed to be zero. 
 lda    leading dimension of A. It must be at least max (1, n).
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision complex scalar multiplier applied to vector y.
 y      single precision complex array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/chemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasChbmv(char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasChbmv</H3>
<PRE>
public static void <B>cublasChbmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasChbmv (char uplo, int n, int k, cuComplex alpha, const cuComplex *A, int lda,
              const cuComplex *x, int incx, cuComplex beta, cuComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are single precision complex scalars. x and y are single precision
 complex vectors with n elements. A is an n by n hermitian band matrix consisting 
 of single precision complex elements, with k super-diagonals and the same number
 of subdiagonals.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the hermitian
        band matrix A is being supplied. If uplo == 'U' or 'u', the upper 
        triangular part is being supplied. If uplo == 'L' or 'l', the lower 
        triangular part is being supplied.
 n      specifies the number of rows and the number of columns of the
        hermitian matrix A. n must be at least zero.
 k      specifies the number of super-diagonals of matrix A. Since the matrix
        is hermitian, this is also the number of sub-diagonals. k must be at
        least zero.
 alpha  single precision complex scalar multiplier applied to A*x.
 A      single precision complex array of dimensions (lda, n). When uplo == 'U' or 
        'u', the leading (k + 1) x n part of array A must contain the upper
        triangular band of the hermitian matrix, supplied column by column,
        with the leading diagonal of the matrix in row (k+1) of the array,
        the first super-diagonal starting at position 2 in row k, and so on.
        The top left k x k triangle of the array A is not referenced. When
        uplo == 'L' or 'l', the leading (k + 1) x n part of the array A must
        contain the lower triangular band part of the hermitian matrix, 
        supplied column by column, with the leading diagonal of the matrix in
        row 1 of the array, the first sub-diagonal starting at position 1 in
        row 2, and so on. The bottom right k x k triangle of the array A is
        not referenced. The imaginary parts of the diagonal elements need 
        not be set, they are assumed to be zero. 
 lda    leading dimension of A. lda must be at least (k + 1).
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   single precision complex scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      single precision complex array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read.
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/chbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized 
 CUBLAS_STATUS_INVALID_VALUE    if k or n < 0, or if incx or incy == 0  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtrmv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtrmv</H3>
<PRE>
public static void <B>cublasCtrmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 
 cublasCtrmv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, 
 where op(A) = A, or op(A) = transpose(A) or op(A) = conjugate(transpose(A)). 
 x is an n-element signle precision complex vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular 
        matrix. If uplo = 'U' or 'u', then A is an upper triangular matrix. 
        If uplo = 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If trans = 'n' or 'N', op(A) = A. If trans = 't' or
        'T', op(A) = transpose(A).  If trans = 'c' or 'C', op(A) =
        conjugate(transpose(A)).
 diag   specifies whether or not matrix A is unit triangular. If diag = 'U' 
        or 'u', A is assumed to be unit triangular. If diag = 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero.
 A      single precision array of dimension (lda, n). If uplo = 'U' or 'u', 
        the leading n x n upper triangular part of the array A must contain 
        the upper triangular matrix and the strictly lower triangular part 
        of A is not referenced. If uplo = 'L' or 'l', the leading n x n lower
        triangular part of the array A must contain the lower triangular 
        matrix and the strictly upper triangular part of A is not referenced.
        When diag = 'U' or 'u', the diagonal elements of A are not referenced
        either, but are are assumed to be unity.
 lda    is the leading dimension of A. It must be at least max (1, n).
 x      single precision array of length at least (1 + (n - 1) * abs(incx) ).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/ctrmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtbmv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtbmv</H3>
<PRE>
public static void <B>cublasCtbmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasCtbmv (char uplo, char trans, char diag, int n, int k, const cuComplex *A,
              int lda, cuComplex *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)). x is an n-element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper 
 or lower triangular band matrix composed of single precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular band
        matrix. If uplo == 'U' or 'u', A is an upper triangular band matrix.
        If uplo == 'L' or 'l', A is a lower triangular band matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        or 't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)).
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or 
        'u', k specifies the number of super-diagonals. If uplo == 'L' or 
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      single precision complex array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper 
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first 
        super-diagonal starting at position 2 in row k, and so on. The top
        left k x k triangle of the array A is not referenced. If uplo == 'L'
        or 'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first 
        sub-diagonal startingat position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 lda    is the leading dimension of A. It must be at least (k + 1).
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x

 Reference: http://www.netlib.org/blas/ctbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n or k < 0, or if incx == 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtpmv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasCtpmv</H3>
<PRE>
public static void <B>cublasCtpmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasCtpmv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 op(A) = transpose(A) or op(A) = conjugate(transpose(A)) . x is an n element 
 single precision complex vector, and A is an n x n, unit or non-unit, upper
 or lower triangular matrix composed of single precision complex elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo == 'U' or 'u', then A is an upper triangular matrix.
        If uplo == 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        or 't', op(A) = transpose(A). If trans == 'C' or 'c', 
        op(A) = conjugate(transpose(A)).

 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero. In the current implementation n must not exceed 4070.
 AP     single precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored in AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/ctpmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or n < 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtrsv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtrsv</H3>
<PRE>
public static void <B>cublasCtrsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasCtrsv (char uplo, char trans, char diag, int n, const cuComplex *A, 
              int lda, cuComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are single precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.
 Matrix A is stored in column major format, and lda is the leading 
 dimension of the two-dimensional array containing A.

 No test for singularity or near-singularity is included in this function. 
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the 
        lower triangular part of array A. If uplo = 'U' or 'u', then only 
        the upper triangular part of A may be referenced. If uplo = 'L' or 
        'l', then only the lower triangular part of A may be referenced.
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If transa = 't',
        'T', 'c', or 'C', op(A) = transpose(A)
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If 
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0. 
 A      is a single precision complex array of dimensions (lda, n). If uplo = 'U' 
        or 'u', then A must contains the upper triangular part of a symmetric
        matrix, and the strictly lower triangular parts is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part of 
        a symmetric matrix, and the strictly upper triangular part is not 
        referenced. 
 lda    is the leading dimension of the two-dimensional array containing A.
        lda must be at least max(1, n).
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the n element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ctrsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtbsv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtbsv</H3>
<PRE>
public static void <B>cublasCtbsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void cublasCtbsv (char uplo, char trans, char diag, int n, int k,
                   const cuComplex *A, int lda, cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose(A)).
 b and x are n element vectors, and A is an n x n unit or non-unit,
 upper or lower triangular band matrix with k + 1 diagonals. No test
 for singularity or near-singularity is included in this function.
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular band 
        matrix as follows: If uplo == 'U' or 'u', A is an upper triangular
        band matrix. If uplo == 'L' or 'l', A is a lower triangular band
        matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', op(A) = transpose(A). If trans == 'C' or 'c',
        op(A) = conjugate(transpose(A)). 
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or
        'u', k specifies the number of super-diagonals. If uplo == 'L' or
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      single precision complex array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first super-
        diagonal starting at position 2 in row k, and so on. The top left 
        k x k triangle of the array A is not referenced. If uplo == 'L' or 
        'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first
        sub-diagonal starting at position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 x      single precision complex array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ctbsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0, n < 0 or n > 2035
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtpsv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasCtpsv</H3>
<PRE>
public static void <B>cublasCtpsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasCtpsv (char uplo, char trans, char diag, int n, const cuComplex *AP, 
              cuComplex *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A , op(A) = transpose(A) or op(A) = conjugate(transpose)). b and
 x are n element complex vectors, and A is an n x n unit or non-unit,
 upper or lower triangular matrix. No test for singularity or near-singularity
 is included in this routine. Such tests must be performed before calling this routine.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular matrix
        as follows: If uplo == 'U' or 'u', A is an upper triangluar matrix.
        If uplo == 'L' or 'l', A is a lower triangular matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T'
        or 't', op(A) = transpose(A). If trans == 'C' or 'c', op(A) = 
        conjugate(transpose(A)).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 AP     single precision complex array with at least ((n*(n+1))/2) elements.
        If uplo == 'U' or 'u', the array AP contains the upper triangular
        matrix A, packed sequentially, column by column; that is, if i <= j, then 
        A[i,j] is stored is AP[i+(j*(j+1)/2)]. If uplo == 'L' or 'L', the 
        array AP contains the lower triangular matrix A, packed sequentially,
        column by column; that is, if i >= j, then A[i,j] is stored in 
        AP[i+((2*n-j+1)*j)/2]. When diag = 'U' or 'u', the diagonal elements
        of A are not referenced and are assumed to be unity.
 x      single precision complex array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ctpsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0 or n > 2035 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCgeru(int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCgeru</H3>
<PRE>
public static void <B>cublasCgeru</B>(int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasCgeru (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.
 
 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least 
        zero.
 n      specifies the number of columns of the matrix A. It must be at 
        least zero.
 alpha  single precision complex scalar multiplier applied to x * transpose(y)
 x      single precision complex array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      single precision complex array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not 
        be zero.
 A      single precision complex array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * transpose(y) + A

 Reference: http://www.netlib.org/blas/cgeru.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m <0, n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCgerc(int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCgerc</H3>
<PRE>
public static void <B>cublasCgerc</B>(int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasCgerc (int m, int n, cuComplex alpha, const cuComplex *x, int incx, 
             const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a single precision complex scalar, x is an m element single 
 precision complex vector, y is an n element single precision complex vector, and A 
 is an m by n matrix consisting of single precision complex elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.
 
 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least 
        zero.
 n      specifies the number of columns of the matrix A. It must be at 
        least zero.
 alpha  single precision complex scalar multiplier applied to x * transpose(y)
 x      single precision complex array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      single precision complex array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not 
        be zero.
 A      single precision complex array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(y)) + A

 Reference: http://www.netlib.org/blas/cgerc.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m <0, n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCher(char, int, float, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCher</H3>
<PRE>
public static void <B>cublasCher</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              float&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void 
 cublasCher (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a single precision real scalar, x is an n element single 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 single precision complex elements. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array 
 containing A.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or 
        the lower triangular part of array A. If uplo = 'U' or 'u',
        then only the upper triangular part of A may be referenced.
        If uplo = 'L' or 'l', then only the lower triangular part of
        A may be referenced.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0.
 alpha  single precision real scalar multiplier applied to 
        x * conjugate(transpose(x))
 x      single precision complex array of length at least (1 + (n - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must 
        not be zero.
 A      single precision complex array of dimensions (lda, n). If uplo = 'U' or 
        'u', then A must contain the upper triangular part of a hermitian 
        matrix, and the strictly lower triangular part is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part 
        of a hermitian matrix, and the strictly upper triangular part is 
        not referenced. The imaginary parts of the diagonal elements need
        not be set, they are assumed to be zero, and on exit they
        are set to zero. 
 lda    leading dimension of the two-dimensional array containing A. lda
        must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(x)) + A

 Reference: http://www.netlib.org/blas/cher.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasChpr(char, int, float, Pointer, int, Pointer)"><!-- --></A><H3>
cublasChpr</H3>
<PRE>
public static void <B>cublasChpr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              float&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre>
 void 
 cublasChpr (char uplo, int n, float alpha, const cuComplex *x, int incx, 
             cuComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a single precision real scalar and x is an n element single 
 precision complex vector. A is a hermitian n x n matrix consisting of single 
 precision complex elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision real scalar multiplier applied to x * conjugate(transpose(x)).
 x      single precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 AP     single precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
        The imaginary parts of the diagonal elements need not be set, they
        are assumed to be zero, and on exit they are set to zero. 

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(x)) + A

 Reference: http://www.netlib.org/blas/chpr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasChpr2(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer)"><!-- --></A><H3>
cublasChpr2</H3>
<PRE>
public static void <B>cublasChpr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre> 
 void 
 cublasChpr2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
              const cuComplex *y, int incy, cuComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, and x and y are n element single 
 precision complex vectors. A is a hermitian n x n matrix consisting of single 
 precision complex elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision complex scalar multiplier applied to x * conjugate(transpose(y)) + 
        y * conjugate(transpose(x)).
 x      single precision complex array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      single precision complex array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 AP     single precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
        The imaginary parts of the diagonal elements need not be set, they
        are assumed to be zero, and on exit they are set to zero.  

 Output
 ------
 A      updated according to A = alpha*x*conjugate(transpose(y))
                               + conjugate(alpha)*y*conjugate(transpose(x))+A

 Reference: http://www.netlib.org/blas/chpr2.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCher2(char, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCher2</H3>
<PRE>
public static void <B>cublasCher2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void cublasCher2 (char uplo, int n, cuComplex alpha, const cuComplex *x, int incx, 
                   const cuComplex *y, int incy, cuComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a single precision complex scalar, x and y are n element single 
 precision complex vector and A is an n by n hermitian matrix consisting of single 
 precision complex elements.
 
 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  single precision complex scalar multiplier applied to x * conjugate(transpose(y)) + 
        y * conjugate(transpose(x)).
 x      single precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      single precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 A      single precision complex array of dimensions (lda, n). If uplo == 'U' or 'u',
        then A must contains the upper triangular part of a hermitian matrix,
        and the strictly lower triangular parts is not referenced. If uplo ==
        'L' or 'l', then A contains the lower triangular part of a hermitian 
        matrix, and the strictly upper triangular part is not referenced.
        The imaginary parts of the diagonal elements need not be set, 
        they are assumed to be zero, and on exit they are set to zero. 

 lda    leading dimension of A. It must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha*x*conjugate(transpose(y))
                               + conjugate(alpha)*y*conjugate(transpose(x))+A

 Reference: http://www.netlib.org/blas/cher2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSgemm(char, char, int, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSgemm</H3>
<PRE>
public static void <B>cublasSgemm</B>(char&nbsp;transa,
                               char&nbsp;transb,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;k,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               float&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasSgemm (char transa, char transb, int m, int n, int k, float alpha, 
              const float *A, int lda, const float *B, int ldb, float beta, 
              float *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by a scalar alpha, and adds the sum to the product of matrix C and
 scalar beta. sgemm() performs one of the matrix-matrix operations:

     C = alpha * op(A) * op(B) + beta * C,

 where op(X) is one of

     op(X) = X   or   op(X) = transpose(X)

 alpha and beta are single precision scalars, and A, B and C are 
 matrices consisting of single precision elements, with op(A) an m x k 
 matrix, op(B) a k x n matrix, and C an m x n matrix. Matrices A, B, 
 and C are stored in column major format, and lda, ldb, and ldc are
 the leading dimensions of the two-dimensional arrays containing A, 
 B, and C.

 Input
 -----
 transa specifies op(A). If transa = 'n' or 'N', op(A) = A. If 
        transa = 't', 'T', 'c', or 'C', op(A) = transpose(A)
 transb specifies op(B). If transb = 'n' or 'N', op(B) = B. If 
        transb = 't', 'T', 'c', or 'C', op(B) = transpose(B)
 m      number of rows of matrix op(A) and rows of matrix C
 n      number of columns of matrix op(B) and number of columns of C
 k      number of columns of matrix op(A) and number of rows of op(B) 
 alpha  single precision scalar multiplier applied to op(A)op(B)
 A      single precision array of dimensions (lda, k) if transa = 
        'n' or 'N'), and of dimensions (lda, m) otherwise. When transa =
        'N' or 'n' then lda must be at least  max( 1, m ), otherwise lda
        must be at least max(1, k).
 lda    leading dimension of two-dimensional array used to store matrix A
 B      single precision array of dimensions  (ldb, n) if transb =
        'n' or 'N'), and of dimensions (ldb, k) otherwise. When transb =
        'N' or 'n' then ldb must be at least  max (1, k), otherwise ldb
        must be at least max (1, n).
 ldb    leading dimension of two-dimensional array used to store matrix B
 beta   single precision scalar multiplier applied to C. If 0, C does
        not have to be a valid input
 C      single precision array of dimensions (ldc, n). ldc must be at 
        least max (1, m).
 ldc    leading dimension of two-dimensional array used to store matrix C

 Output
 ------
 C      updated based on C = alpha * op(A)*op(B) + beta * C

 Reference: http://www.netlib.org/blas/sgemm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if any of m, n, or k are < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsymm(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSsymm</H3>
<PRE>
public static void <B>cublasSsymm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               float&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsymm (char side, char uplo, int m, int n, float alpha, 
              const float *A, int lda, const float *B, int ldb, 
              float beta, float *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision scalars, A is a symmetric matrix
 consisting of single precision elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 elements.

 Input
 -----
 side   specifies whether the symmetric matrix A appears on the left side 
        hand side or right hand side of matrix B, as follows. If side == 'L' 
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r', 
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the symmetric matrix A is stored in upper or lower 
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of symmetric matrix A 
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of 
        columns of matrix B. It also specifies the dimensions of symmetric 
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  single precision scalar multiplier applied to A * B, or B * A
 A      single precision array of dimensions (lda, ka), where ka is m when 
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the 
        leading m x m part of array A must contain the symmetric matrix, 
        such that when uplo == 'U' or 'u', the leading m x m part stores the 
        upper triangular part of the symmetric matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u', 
        the leading m x m part stores the lower triangular part of the 
        symmetric matrix and the strictly upper triangular part is not 
        referenced. If side == 'R' or 'r' the leading n x n part of array A 
        must contain the symmetric matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the 
        symmetric matrix and the strictly lower triangular part of A is not 
        referenced, and when uplo == 'U' or 'u', the leading n x n part 
        stores the lower triangular part of the symmetric matrix and the 
        strictly upper triangular part is not referenced.
 lda    leading dimension of A. When side == 'L' or 'l', it must be at least 
        max(1, m) and at least max(1, n) otherwise.
 B      single precision array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   single precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input
 C      single precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha * 
        B * A + beta * C

 Reference: http://www.netlib.org/blas/ssymm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsyrk(char, char, int, int, float, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSsyrk</H3>
<PRE>
public static void <B>cublasSsyrk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               float&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsyrk (char uplo, char trans, int n, int k, float alpha, 
              const float *A, int lda, float beta, float *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.

 Alpha and beta are single precision scalars. C is an n x n symmetric matrix 
 consisting of single precision elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of single precision elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * transpose(A) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = transpose(A) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision scalar multiplier applied to A * transpose(A) or 
        transpose(A) * A.
 A      single precision array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   single precision scalar multiplier applied to C. If beta izs zero, C
        does not have to be a valid input
 C      single precision array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * transpose(A) + beta * C, or C = 
        alpha * transpose(A) * A + beta * C

 Reference: http://www.netlib.org/blas/ssyrk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasSsyr2k(char, char, int, int, float, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasSsyr2k</H3>
<PRE>
public static void <B>cublasSsyr2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                float&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                float&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasSsyr2k (char uplo, char trans, int n, int k, float alpha, 
               const float *A, int lda, const float *B, int ldb, 
               float beta, float *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.

 Alpha and beta are single precision scalars. C is an n x n symmetric matrix
 consisting of single precision elements and stored in either lower or upper 
 storage mode. A and B are matrices consisting of single precision elements 
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be references, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', 
        C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, 
        If trans == 'T', 't', 'C', or 'c', C = alpha * transpose(A) * B + 
        alpha * transpose(B) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision scalar multiplier.
 A      single precision array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at 
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      single precision array of dimensions (lda, kb), where kb is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array B must contain the matrix B, 
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   single precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      single precision array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*transpose(B) + alpha*B*transpose(A) + 
        beta*C or alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C

 Reference:   http://www.netlib.org/blas/ssyr2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStrmm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStrmm</H3>
<PRE>
public static void <B>cublasStrmm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void 
 cublasStrmm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, const float *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision scalar, B is an m x n matrix composed
 of single precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.

 Input
 -----
 side   specifies whether op(A) multiplies B from the left or right.
        If side = 'L' or 'l', then B = alpha * op(A) * B. If side =
        'R' or 'r', then B = alpha * B * op(A).
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo = 'U' or 'u', A is an upper triangular matrix.
        If uplo = 'L' or 'l', A is a lower triangular matrix.
 transa specifies the form of op(A) to be used in the matrix 
        multiplication. If transa = 'N' or 'n', then op(A) = A. If
        transa = 'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is unit triangular. If diag = 'U'
        or 'u', A is assumed to be unit triangular. If diag = 'N' or
        'n', A is not assumed to be unit triangular.
 m      the number of rows of matrix B. m must be at least zero.
 n      the number of columns of matrix B. n must be at least zero.
 alpha  single precision scalar multiplier applied to op(A)*B, or
        B*op(A), respectively. If alpha is zero no accesses are made
        to matrix A, and no read accesses are made to matrix B.
 A      single precision array of dimensions (lda, k). k = m if side =
        'L' or 'l', k = n if side = 'R' or 'r'. If uplo = 'U' or 'u'
        the leading k x k upper triangular part of the array A must
        contain the upper triangular matrix, and the strictly lower
        triangular part of A is not referenced. If uplo = 'L' or 'l'
        the leading k x k lower triangular part of the array A must
        contain the lower triangular matrix, and the strictly upper
        triangular part of A is not referenced. When diag = 'U' or 'u'
        the diagonal elements of A are no referenced and are assumed
        to be unity.
 lda    leading dimension of A. When side = 'L' or 'l', it must be at
        least max(1,m) and at least max(1,n) otherwise
 B      single precision array of dimensions (ldb, n). On entry, the 
        leading m x n part of the array contains the matrix B. It is
        overwritten with the transformed matrix on exit.
 ldb    leading dimension of B. It must be at least max (1, m).

 Output
 ------
 B      updated according to B = alpha * op(A) * B  or B = alpha * B * op(A)

 Reference: http://www.netlib.org/blas/strmm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasStrsm(char, char, char, char, int, int, float, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasStrsm</H3>
<PRE>
public static void <B>cublasStrsm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void 
 cublasStrsm (char side, char uplo, char transa, char diag, int m, int n, 
              float alpha, const float *A, int lda, float *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision scalar, and X and B are m x n matrices 
 that are composed of single precision elements. A is a unit or non-unit,
 upper or lower triangular matrix, and op(A) is one of 

    op(A) = A  or  op(A) = transpose(A)

 The result matrix X overwrites input matrix B; that is, on exit the result 
 is stored in B. Matrices A and B are stored in column major format, and
 lda and ldb are the leading dimensions of the two-dimensonials arrays that
 contain A and B, respectively.

 Input
 -----
 side   specifies whether op(A) appears on the left or right of X as
        follows: side = 'L' or 'l' indicates solve op(A) * X = alpha * B.
        side = 'R' or 'r' indicates solve X * op(A) = alpha * B.
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix as follows: uplo = 'U' or 'u' indicates A is an upper
        triangular matrix. uplo = 'L' or 'l' indicates A is a lower
        triangular matrix.
 transa specifies the form of op(A) to be used in matrix multiplication
        as follows: If transa = 'N' or 'N', then op(A) = A. If transa =
        'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If 
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 m      specifies the number of rows of B. m must be at least zero.
 n      specifies the number of columns of B. n must be at least zero.
 alpha  is a single precision scalar to be multiplied with B. When alpha is 
        zero, then A is not referenced and B need not be set before entry.
 A      is a single precision array of dimensions (lda, k), where k is
        m when side = 'L' or 'l', and is n when side = 'R' or 'r'. If
        uplo = 'U' or 'u', the leading k x k upper triangular part of
        the array A must contain the upper triangular matrix and the
        strictly lower triangular matrix of A is not referenced. When
        uplo = 'L' or 'l', the leading k x k lower triangular part of
        the array A must contain the lower triangular matrix and the 
        strictly upper triangular part of A is not referenced. Note that
        when diag = 'U' or 'u', the diagonal elements of A are not
        referenced, and are assumed to be unity.
 lda    is the leading dimension of the two dimensional array containing A.
        When side = 'L' or 'l' then lda must be at least max(1, m), when 
        side = 'R' or 'r' then lda must be at least max(1, n).
 B      is a single precision array of dimensions (ldb, n). ldb must be
        at least max (1,m). The leading m x n part of the array B must 
        contain the right-hand side matrix B. On exit B is overwritten 
        by the solution matrix X.
 ldb    is the leading dimension of the two dimensional array containing B.
        ldb must be at least max(1, m).

 Output
 ------
 B      contains the solution matrix X satisfying op(A) * X = alpha * B, 
        or X * op(A) = alpha * B

 Reference: http://www.netlib.org/blas/strsm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCgemm(char, char, int, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCgemm</H3>
<PRE>
public static void <B>cublasCgemm</B>(char&nbsp;transa,
                               char&nbsp;transb,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void cublasCgemm (char transa, char transb, int m, int n, int k, 
                   cuComplex alpha, const cuComplex *A, int lda, 
                   const cuComplex *B, int ldb, cuComplex beta, 
                   cuComplex *C, int ldc)

 performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are single-complex scalars, and A, B and C are matrices
 consisting of single-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.

 Input
 -----
 transa specifies op(A). If transa == 'N' or 'n', op(A) = A. If transa == 
        'T' or 't', op(A) = transpose(A). If transa == 'C' or 'c', op(A) = 
        conjg(transpose(A)).
 transb specifies op(B). If transa == 'N' or 'n', op(B) = B. If transb == 
        'T' or 't', op(B) = transpose(B). If transb == 'C' or 'c', op(B) = 
        conjg(transpose(B)).
 m      number of rows of matrix op(A) and rows of matrix C. It must be at
        least zero.
 n      number of columns of matrix op(B) and number of columns of C. It 
        must be at least zero.
 k      number of columns of matrix op(A) and number of rows of op(B). It 
        must be at least zero.
 alpha  single-complex scalar multiplier applied to op(A)op(B)
 A      single-complex array of dimensions (lda, k) if transa ==  'N' or 
        'n'), and of dimensions (lda, m) otherwise.
 lda    leading dimension of A. When transa == 'N' or 'n', it must be at 
        least max(1, m) and at least max(1, k) otherwise.
 B      single-complex array of dimensions (ldb, n) if transb == 'N' or 'n', 
        and of dimensions (ldb, k) otherwise
 ldb    leading dimension of B. When transb == 'N' or 'n', it must be at 
        least max(1, k) and at least max(1, n) otherwise.
 beta   single-complex scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      single precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m).

 Output
 ------
 C      updated according to C = alpha*op(A)*op(B) + beta*C

 Reference: http://www.netlib.org/blas/cgemm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if any of m, n, or k are < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCsymm(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCsymm</H3>
<PRE>
public static void <B>cublasCsymm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasCsymm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a symmetric matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.

 Input
 -----
 side   specifies whether the symmetric matrix A appears on the left side 
        hand side or right hand side of matrix B, as follows. If side == 'L' 
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r', 
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the symmetric matrix A is stored in upper or lower 
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of symmetric matrix A 
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of 
        columns of matrix B. It also specifies the dimensions of symmetric 
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  single precision scalar multiplier applied to A * B, or B * A
 A      single precision array of dimensions (lda, ka), where ka is m when 
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the 
        leading m x m part of array A must contain the symmetric matrix, 
        such that when uplo == 'U' or 'u', the leading m x m part stores the 
        upper triangular part of the symmetric matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u', 
        the leading m x m part stores the lower triangular part of the 
        symmetric matrix and the strictly upper triangular part is not 
        referenced. If side == 'R' or 'r' the leading n x n part of array A 
        must contain the symmetric matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the 
        symmetric matrix and the strictly lower triangular part of A is not 
        referenced, and when uplo == 'U' or 'u', the leading n x n part 
        stores the lower triangular part of the symmetric matrix and the 
        strictly upper triangular part is not referenced.
 lda    leading dimension of A. When side == 'L' or 'l', it must be at least 
        max(1, m) and at least max(1, n) otherwise.
 B      single precision array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   single precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input
 C      single precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha * 
        B * A + beta * C

 Reference: http://www.netlib.org/blas/csymm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasChemm(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasChemm</H3>
<PRE>
public static void <B>cublasChemm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasChemm (char side, char uplo, int m, int n, cuComplex alpha, 
              const cuComplex *A, int lda, const cuComplex *B, int ldb, 
              cuComplex beta, cuComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are single precision complex scalars, A is a hermitian matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of single precision
 complex elements.

 Input
 -----
 side   specifies whether the hermitian matrix A appears on the left side 
        hand side or right hand side of matrix B, as follows. If side == 'L' 
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r', 
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the hermitian matrix A is stored in upper or lower 
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of hermitian matrix A 
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of 
        columns of matrix B. It also specifies the dimensions of hermitian 
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  single precision complex scalar multiplier applied to A * B, or B * A
 A      single precision complex array of dimensions (lda, ka), where ka is m when 
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the 
        leading m x m part of array A must contain the hermitian matrix, 
        such that when uplo == 'U' or 'u', the leading m x m part stores the 
        upper triangular part of the hermitian matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u', 
        the leading m x m part stores the lower triangular part of the 
        hermitian matrix and the strictly upper triangular part is not 
        referenced. If side == 'R' or 'r' the leading n x n part of array A 
        must contain the hermitian matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the 
        hermitian matrix and the strictly lower triangular part of A is not 
        referenced, and when uplo == 'U' or 'u', the leading n x n part 
        stores the lower triangular part of the hermitian matrix and the 
        strictly upper triangular part is not referenced. The imaginary parts
        of the diagonal elements need not be set, they are assumed to be zero.
 lda    leading dimension of A. When side == 'L' or 'l', it must be at least 
        max(1, m) and at least max(1, n) otherwise.
 B      single precision complex array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   single precision complex scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input
 C      single precision complex array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha * 
        B * A + beta * C

 Reference: http://www.netlib.org/blas/chemm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCsyrk(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCsyrk</H3>
<PRE>
public static void <B>cublasCsyrk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasCsyrk (char uplo, char trans, int n, int k, cuComplex alpha, 
              const cuComplex *A, int lda, cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.

 Alpha and beta are single precision complex scalars. C is an n x n symmetric matrix 
 consisting of single precision complex elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of single precision complex elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * transpose(A) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = transpose(A) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision complex scalar multiplier applied to A * transpose(A) or 
        transpose(A) * A.
 A      single precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   single precision complex scalar multiplier applied to C. If beta izs zero, C
        does not have to be a valid input
 C      single precision complex array of dimensions (ldc, n). If uplo = 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo = 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * transpose(A) + beta * C, or C = 
        alpha * transpose(A) * A + beta * C

 Reference: http://www.netlib.org/blas/csyrk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCherk(char, char, int, int, float, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasCherk</H3>
<PRE>
public static void <B>cublasCherk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               float&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               float&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasCherk (char uplo, char trans, int n, int k, float alpha, 
              const cuComplex *A, int lda, float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.

 Alpha and beta are single precision real scalars. C is an n x n hermitian matrix 
 consisting of single precision complex elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of single precision complex elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the hermitian matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * A * conjugate(transpose(A)) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = alpha * conjugate(transpose(A)) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of columns of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision scalar multiplier applied to A * conjugate(transpose(A)) or 
        conjugate(transpose(A)) * A.
 A      single precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   single precision scalar multiplier applied to C. If beta is zero, C
        does not have to be a valid input.
 C      single precision complex array of dimensions (ldc, n). If uplo = 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the hermitian matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo = 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the hermitian matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
        The imaginary parts of the diagonal elements need
        not be set,  they are assumed to be zero,  and on exit they
        are set to zero.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * conjugate(transpose(A)) + beta * C, or C = 
        alpha * conjugate(transpose(A)) * A + beta * C

 Reference: http://www.netlib.org/blas/cherk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCsyr2k(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuComplex, Pointer, int)"><!-- --></A><H3>
cublasCsyr2k</H3>
<PRE>
public static void <B>cublasCsyr2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasCsyr2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               cuComplex beta, cuComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.

 Alpha and beta are single precision complex scalars. C is an n x n symmetric matrix
 consisting of single precision complex elements and stored in either lower or upper 
 storage mode. A and B are matrices consisting of single precision complex elements 
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be references, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', 
        C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, 
        If trans == 'T', 't', 'C', or 'c', C = alpha * transpose(A) * B + 
        alpha * transpose(B) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision complex scalar multiplier.
 A      single precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at 
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      single precision complex array of dimensions (lda, kb), where kb is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array B must contain the matrix B, 
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   single precision complex scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      single precision complex array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*transpose(B) + alpha*B*transpose(A) + 
        beta*C or alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C

 Reference:   http://www.netlib.org/blas/csyr2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCher2k(char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int, float, Pointer, int)"><!-- --></A><H3>
cublasCher2k</H3>
<PRE>
public static void <B>cublasCher2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                float&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasCher2k (char uplo, char trans, int n, int k, cuComplex alpha, 
               const cuComplex *A, int lda, const cuComplex *B, int ldb, 
               float beta, cuComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.

 Alpha is single precision complex scalar whereas Beta is a single preocision real scalar. 
 C is an n x n hermitian matrix consisting of single precision complex elements 
 and stored in either lower or upper storage mode. A and B are matrices consisting
 of single precision complex elements with dimension of n x k in the first case,
 and k x n in the second case.

 Input
 -----
 uplo   specifies whether the hermitian matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be references, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', 
        C =   alpha * A * conjugate(transpose(B)) 
            + conjugate(alpha) * B * conjugate(transpose(A))  
            + beta * C .
        If trans == 'T', 't', 'C', or 'c',
        C =  alpha * conjugate(transpose(A)) * B 
          + conjugate(alpha) * conjugate(transpose(B)) * A 
          + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  single precision complex scalar multiplier.
 A      single precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at 
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      single precision complex array of dimensions (lda, kb), where kb is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array B must contain the matrix B, 
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   single precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      single precision complex array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the hermitian matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the hermitian matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
        The imaginary parts of the diagonal elements need
        not be set,  they are assumed to be zero,  and on exit they
        are set to zero.
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*conjugate(transpose(B)) + 
        + conjugate(alpha)*B*conjugate(transpose(A)) + beta*C or
        alpha*conjugate(transpose(A))*B + conjugate(alpha)*conjugate(transpose(B))*A
        + beta*C.

 Reference:   http://www.netlib.org/blas/cher2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtrmm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtrmm</H3>
<PRE>
public static void <B>cublasCtrmm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void 
 cublasCtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuComplex alpha, const cuComplex *A, int lda, const cuComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a single-precision complex scalar, B is an m x n matrix composed
 of single precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of single precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.

 Input
 -----
 side   specifies whether op(A) multiplies B from the left or right.
        If side = 'L' or 'l', then B = alpha * op(A) * B. If side =
        'R' or 'r', then B = alpha * B * op(A).
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo = 'U' or 'u', A is an upper triangular matrix.
        If uplo = 'L' or 'l', A is a lower triangular matrix.
 transa specifies the form of op(A) to be used in the matrix 
        multiplication. If transa = 'N' or 'n', then op(A) = A. If
        transa = 'T' or 't', then op(A) = transpose(A).
        If transa = 'C' or 'c', then op(A) = conjugate(transpose(A)).
 diag   specifies whether or not A is unit triangular. If diag = 'U'
        or 'u', A is assumed to be unit triangular. If diag = 'N' or
        'n', A is not assumed to be unit triangular.
 m      the number of rows of matrix B. m must be at least zero.
 n      the number of columns of matrix B. n must be at least zero.
 alpha  single precision complex scalar multiplier applied to op(A)*B, or
        B*op(A), respectively. If alpha is zero no accesses are made
        to matrix A, and no read accesses are made to matrix B.
 A      single precision complex array of dimensions (lda, k). k = m if side =
        'L' or 'l', k = n if side = 'R' or 'r'. If uplo = 'U' or 'u'
        the leading k x k upper triangular part of the array A must
        contain the upper triangular matrix, and the strictly lower
        triangular part of A is not referenced. If uplo = 'L' or 'l'
        the leading k x k lower triangular part of the array A must
        contain the lower triangular matrix, and the strictly upper
        triangular part of A is not referenced. When diag = 'U' or 'u'
        the diagonal elements of A are no referenced and are assumed
        to be unity.
 lda    leading dimension of A. When side = 'L' or 'l', it must be at
        least max(1,m) and at least max(1,n) otherwise
 B      single precision complex array of dimensions (ldb, n). On entry, the 
        leading m x n part of the array contains the matrix B. It is
        overwritten with the transformed matrix on exit.
 ldb    leading dimension of B. It must be at least max (1, m).

 Output
 ------
 B      updated according to B = alpha * op(A) * B  or B = alpha * B * op(A)

 Reference: http://www.netlib.org/blas/ctrmm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasCtrsm(char, char, char, char, int, int, jcuda.jcublas.cuComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasCtrsm</H3>
<PRE>
public static void <B>cublasCtrsm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuComplex.html" title="class in jcuda.jcublas">cuComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void
 cublasCtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuComplex alpha, const cuComplex *A, int lda,
              cuComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a single precision complex scalar, and X and B are m x n matrices
 that are composed of single precision complex elements. A is a unit or non-unit,
 upper or lower triangular matrix, and op(A) is one of

    op(A) = A  or  op(A) = transpose(A)  or  op( A ) = conj( A' ).

 The result matrix X overwrites input matrix B; that is, on exit the result
 is stored in B. Matrices A and B are stored in column major format, and
 lda and ldb are the leading dimensions of the two-dimensonials arrays that
 contain A and B, respectively.

 Input
 -----
 side   specifies whether op(A) appears on the left or right of X as
        follows: side = 'L' or 'l' indicates solve op(A) * X = alpha * B.
        side = 'R' or 'r' indicates solve X * op(A) = alpha * B.
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix as follows: uplo = 'U' or 'u' indicates A is an upper
        triangular matrix. uplo = 'L' or 'l' indicates A is a lower
        triangular matrix.
 transa specifies the form of op(A) to be used in matrix multiplication
        as follows: If transa = 'N' or 'N', then op(A) = A. If transa =
        'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 m      specifies the number of rows of B. m must be at least zero.
 n      specifies the number of columns of B. n must be at least zero.
 alpha  is a single precision complex scalar to be multiplied with B. When alpha is
        zero, then A is not referenced and B need not be set before entry.
 A      is a single precision complex array of dimensions (lda, k), where k is
        m when side = 'L' or 'l', and is n when side = 'R' or 'r'. If
        uplo = 'U' or 'u', the leading k x k upper triangular part of
        the array A must contain the upper triangular matrix and the
        strictly lower triangular matrix of A is not referenced. When
        uplo = 'L' or 'l', the leading k x k lower triangular part of
        the array A must contain the lower triangular matrix and the
        strictly upper triangular part of A is not referenced. Note that
        when diag = 'U' or 'u', the diagonal elements of A are not
        referenced, and are assumed to be unity.
 lda    is the leading dimension of the two dimensional array containing A.
        When side = 'L' or 'l' then lda must be at least max(1, m), when
        side = 'R' or 'r' then lda must be at least max(1, n).
 B      is a single precision complex array of dimensions (ldb, n). ldb must be
        at least max (1,m). The leading m x n part of the array B must
        contain the right-hand side matrix B. On exit B is overwritten
        by the solution matrix X.
 ldb    is the leading dimension of the two dimensional array containing B.
        ldb must be at least max(1, m).

 Output
 ------
 B      contains the solution matrix X satisfying op(A) * X = alpha * B,
        or X * op(A) = alpha * B

 Reference: http://www.netlib.org/blas/ctrsm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDasum(int, Pointer, int)"><!-- --></A><H3>
cublasDasum</H3>
<PRE>
public static double <B>cublasDasum</B>(int&nbsp;n,
                                 Pointer&nbsp;x,
                                 int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 double 
 cublasDasum (int n, const double *x, int incx)

 computes the sum of the absolute values of the elements of double 
 precision vector x; that is, the result is the sum from i = 0 to n - 1 of 
 abs(x[1 + i * incx]).
 
 Input
 -----
 n      number of elements in input vector
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the double-precision sum of absolute values
 (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/dasum.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDaxpy(int, double, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDaxpy</H3>
<PRE>
public static void <B>cublasDaxpy</B>(int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasDaxpy (int n, double alpha, const double *x, int incx, double *y, 
              int incy)

 multiplies double-precision vector x by double-precision scalar alpha 
 and adds the result to double-precision vector y; that is, it overwrites 
 double-precision y with double-precision alpha * x + y. For i = 0 to n-1,
 it replaces y[ly + i * incy] with alpha * x[lx + i * incx] + y[ly + i*incy],
 where lx = 1 if incx >= 0, else lx = 1 + (1 - n) * incx; ly is defined in a 
 similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 alpha  double-precision scalar multiplier
 x      double-precision vector with n elements
 incx   storage spacing between elements of x
 y      double-precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      double-precision result (unchanged if n <= 0)

 Reference: http://www.netlib.org/blas/daxpy.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library was not initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDcopy(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDcopy</H3>
<PRE>
public static void <B>cublasDcopy</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasDcopy (int n, const double *x, int incx, double *y, int incy)

 copies the double-precision vector x to the double-precision vector y. For 
 i = 0 to n-1, copies x[lx + i * incx] to y[ly + i * incy], where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and ly is defined in a similar 
 way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-precision vector with n elements
 incx   storage spacing between elements of x
 y      double-precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 y      contains double precision vector x

 Reference: http://www.netlib.org/blas/dcopy.f

 Error status for this function can be retrieved via cublasGetError(). 

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDdot(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDdot</H3>
<PRE>
public static double <B>cublasDdot</B>(int&nbsp;n,
                                Pointer&nbsp;x,
                                int&nbsp;incx,
                                Pointer&nbsp;y,
                                int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 double 
 cublasDdot (int n, const double *x, int incx, const double *y, int incy)

 computes the dot product of two double-precision vectors. It returns the 
 dot product of the double precision vectors x and y if successful, and
 0.0f otherwise. It computes the sum for i = 0 to n - 1 of x[lx + i * 
 incx] * y[ly + i * incy], where lx = 1 if incx >= 0, else lx = 1 + (1 - n)
 *incx, and ly is defined in a similar way using incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-precision vector with n elements
 incx   storage spacing between elements of x
 y      double-precision vector with n elements
 incy   storage spacing between elements of y

 Output
 ------
 returns double-precision dot product (zero if n <= 0)

 Reference: http://www.netlib.org/blas/ddot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has nor been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to execute on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDnrm2(int, Pointer, int)"><!-- --></A><H3>
cublasDnrm2</H3>
<PRE>
public static double <B>cublasDnrm2</B>(int&nbsp;n,
                                 Pointer&nbsp;x,
                                 int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 double 
 dnrm2 (int n, const double *x, int incx)

 computes the Euclidean norm of the double-precision n-vector x (with
 storage increment incx). This code uses a multiphase model of 
 accumulation to avoid intermediate underflow and overflow.

 Input
 -----
 n      number of elements in input vector
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns Euclidian norm (0 if n <= 0 or incx <= 0, or if an error occurs)

 Reference: http://www.netlib.org/blas/dnrm2.f
 Reference: http://www.netlib.org/slatec/lin/dnrm2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDrot(int, Pointer, int, Pointer, int, double, double)"><!-- --></A><H3>
cublasDrot</H3>
<PRE>
public static void <B>cublasDrot</B>(int&nbsp;n,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              double&nbsp;sc,
                              double&nbsp;ss)</PRE>
<DL>
<DD><pre>
 void 
 cublasDrot (int n, double *x, int incx, double *y, int incy, double sc, 
             double ss)

 multiplies a 2x2 matrix ( sc ss) with the 2xn matrix ( transpose(x) )
                         (-ss sc)                     ( transpose(y) )

 The elements of x are in x[lx + i * incx], i = 0 ... n - 1, where lx = 1 if 
 incx >= 0, else lx = 1 + (1 - n) * incx, and similarly for y using ly and 
 incy.

 Input
 -----
 n      number of elements in input vectors
 x      double-precision vector with n elements
 incx   storage spacing between elements of x
 y      double-precision vector with n elements
 incy   storage spacing between elements of y
 sc     element of rotation matrix
 ss     element of rotation matrix

 Output
 ------
 x      rotated vector x (unchanged if n <= 0)
 y      rotated vector y (unchanged if n <= 0)

 Reference  http://www.netlib.org/blas/drot.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDrotg(Pointer, Pointer, Pointer, Pointer)"><!-- --></A><H3>
cublasDrotg</H3>
<PRE>
public static void <B>cublasDrotg</B>(Pointer&nbsp;host_sa,
                               Pointer&nbsp;host_sb,
                               Pointer&nbsp;host_sc,
                               Pointer&nbsp;host_ss)</PRE>
<DL>
<DD><pre>
 void 
 cublasDrotg (double *host_sa, double *host_sb, double *host_sc, double *host_ss)

 constructs the Givens tranformation

        ( sc  ss )
    G = (        ) ,  sc^2 + ss^2 = 1,
        (-ss  sc )

 which zeros the second entry of the 2-vector transpose(sa, sb).

 The quantity r = (+/-) sqrt (sa^2 + sb^2) overwrites sa in storage. The 
 value of sb is overwritten by a value z which allows sc and ss to be 
 recovered by the following algorithm:

    if z=1          set sc = 0.0 and ss = 1.0
    if abs(z) < 1   set sc = sqrt(1-z^2) and ss = z
    if abs(z) > 1   set sc = 1/z and ss = sqrt(1-sc^2)

 The function drot (n, x, incx, y, incy, sc, ss) normally is called next
 to apply the transformation to a 2 x n matrix.
 Note that is function is provided for completeness and run exclusively 
 on the Host.

 Input
 -----
 sa     double-precision scalar
 sb     double-precision scalar

 Output
 ------
 sa     double-precision r
 sb     double-precision z
 sc     double-precision result
 ss     double-precision result

 Reference: http://www.netlib.org/blas/drotg.f

 This function does not set any error status.
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDscal(int, double, Pointer, int)"><!-- --></A><H3>
cublasDscal</H3>
<PRE>
public static void <B>cublasDscal</B>(int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void
 cublasDscal (int n, double alpha, double *x, int incx)

 replaces double-precision vector x with double-precision alpha * x. For 
 i = 0 to n-1, it replaces x[lx + i * incx] with alpha * x[lx + i * incx],
 where lx = 1 if incx >= 0, else lx = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vector
 alpha  double-precision scalar multiplier
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      double-precision result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/dscal.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library was not initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDswap(int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDswap</H3>
<PRE>
public static void <B>cublasDswap</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void
 cublasDswap (int n, double *x, int incx, double *y, int incy)

 replaces double-precision vector x with double-precision alpha * x. For i 
 = 0 to n - 1, it replaces x[ix + i * incx] with alpha * x[ix + i * incx], 
 where ix = 1 if incx >= 0, else ix = 1 + (1 - n) * incx.

 Input
 -----
 n      number of elements in input vectors
 alpha  double-precision scalar multiplier
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 x      double precision result (unchanged if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/dswap.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIdamax(int, Pointer, int)"><!-- --></A><H3>
cublasIdamax</H3>
<PRE>
public static int <B>cublasIdamax</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 idamax (int n, const double *x, int incx)

 finds the smallest index of the maximum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that maximizes abs(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/blas/idamax.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasIdamin(int, Pointer, int)"><!-- --></A><H3>
cublasIdamin</H3>
<PRE>
public static int <B>cublasIdamin</B>(int&nbsp;n,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 int 
 idamin (int n, const double *x, int incx)

 finds the smallest index of the minimum magnitude element of double-
 precision vector x; that is, the result is the first i, i = 0 to n - 1, 
 that minimizes abs(x[1 + i * incx])).
 
 Input
 -----
 n      number of elements in input vector
 x      double-precision vector with n elements
 incx   storage spacing between elements of x

 Output
 ------
 returns the smallest index (0 if n <= 0 or incx <= 0)

 Reference: http://www.netlib.org/scilib/blass.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDgemv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDgemv</H3>
<PRE>
public static void <B>cublasDgemv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               double&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 cublasDgemv (char trans, int m, int n, double alpha, const double *A, 
              int lda, const double *x, int incx, double beta, double *y, 
              int incy)

 performs one of the matrix-vector operations

    y = alpha * op(A) * x + beta * y,

 where op(A) is one of

    op(A) = A   or   op(A) = transpose(A)

 where alpha and beta are double precision scalars, x and y are double 
 precision vectors, and A is an m x n matrix consisting of double precision
 elements. Matrix A is stored in column major format, and lda is the leading
 dimension of the two-dimensional array in which A is stored.

 Input
 -----
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If trans =
        trans = 't', 'T', 'c', or 'C', op(A) = transpose(A)
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least 
        zero.
 alpha  double precision scalar multiplier applied to op(A).
 A      double precision array of dimensions (lda, n) if trans = 'n' or 
        'N'), and of dimensions (lda, m) otherwise. lda must be at least 
        max(1, m) and at least max(1, n) otherwise.
 lda    leading dimension of two-dimensional array used to store matrix A
 x      double precision array of length at least (1 + (n - 1) * abs(incx))
        when trans = 'N' or 'n' and at least (1 + (m - 1) * abs(incx)) 
        otherwise.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.
 beta   double precision scalar multiplier applied to vector y. If beta 
        is zero, y is not read.
 y      double precision array of length at least (1 + (m - 1) * abs(incy))
        when trans = 'N' or 'n' and at least (1 + (n - 1) * abs(incy)) 
        otherwise.
 incy   specifies the storage spacing between elements of x. incx must not
        be zero.

 Output
 ------
 y      updated according to alpha * op(A) * x + beta * y

 Reference: http://www.netlib.org/blas/dgemv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDger(int, int, double, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDger</H3>
<PRE>
public static void <B>cublasDger</B>(int&nbsp;m,
                              int&nbsp;n,
                              double&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;y,
                              int&nbsp;incy,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasDger (int m, int n, double alpha, const double *x, int incx,
             const double *y, int incy, double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision scalar, x is an m element double
 precision vector, y is an n element double precision vector, and A
 is an m by n matrix consisting of double precision elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.

 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least
        zero.
 n      specifies the number of columns of the matrix A. It must be at
        least zero.
 alpha  double precision scalar multiplier applied to x * transpose(y)
 x      double precision array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      double precision array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not
        be zero.
 A      double precision array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * transpose(y) + A

 Reference: http://www.netlib.org/blas/dger.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsyr(char, int, double, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDsyr</H3>
<PRE>
public static void <B>cublasDsyr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              double&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void 
 cublasDsyr (char uplo, int n, double alpha, const double *x, int incx, 
             double *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(x) + A,

 where alpha is a double precision scalar, x is an n element double 
 precision vector and A is an n x n symmetric matrix consisting of 
 double precision elements. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array 
 containing A.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or 
        the lower triangular part of array A. If uplo = 'U' or 'u',
        then only the upper triangular part of A may be referenced.
        If uplo = 'L' or 'l', then only the lower triangular part of
        A may be referenced.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0.
 alpha  double precision scalar multiplier applied to x * transpose(x)
 x      double precision array of length at least (1 + (n - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must 
        not be zero.
 A      double precision array of dimensions (lda, n). If uplo = 'U' or 
        'u', then A must contain the upper triangular part of a symmetric 
        matrix, and the strictly lower triangular part is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part 
        of a symmetric matrix, and the strictly upper triangular part is 
        not referenced.
 lda    leading dimension of the two-dimensional array containing A. lda
        must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha * x * transpose(x) + A

 Reference: http://www.netlib.org/blas/dsyr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsyr2(char, int, double, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDsyr2</H3>
<PRE>
public static void <B>cublasDsyr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void cublasDsyr2 (char uplo, int n, double alpha, const double *x, int incx, 
                   const double *y, int incy, double *A, int lda)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, x and y are n element double 
 precision vector and A is an n by n symmetric matrix consisting of double 
 precision elements.
 
 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision scalar multiplier applied to x * transpose(y) + 
        y * transpose(x).
 x      double precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      double precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 A      double precision array of dimensions (lda, n). If uplo == 'U' or 'u',
        then A must contains the upper triangular part of a symmetric matrix,
        and the strictly lower triangular parts is not referenced. If uplo ==
        'L' or 'l', then A contains the lower triangular part of a symmetric 
        matrix, and the strictly upper triangular part is not referenced.
 lda    leading dimension of A. It must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha*x*transpose(y)+alpha*y*transpose(x)+A

 Reference: http://www.netlib.org/blas/dsyr2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDspr(char, int, double, Pointer, int, Pointer)"><!-- --></A><H3>
cublasDspr</H3>
<PRE>
public static void <B>cublasDspr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              double&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre>
 void 
 cublasDspr (char uplo, int n, double alpha, const double *x, int incx, 
             double *AP)

 performs the symmetric rank 1 operation
 
    A = alpha * x * transpose(x) + A,
 
 where alpha is a double precision scalar and x is an n element double 
 precision vector. A is a symmetric n x n matrix consisting of double 
 precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision scalar multiplier applied to x * transpose(x).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 AP     double precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].

 Output
 ------
 A      updated according to A = alpha * x * transpose(x) + A

 Reference: http://www.netlib.org/blas/dspr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDspr2(char, int, double, Pointer, int, Pointer, int, Pointer)"><!-- --></A><H3>
cublasDspr2</H3>
<PRE>
public static void <B>cublasDspr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre> 
 void 
 cublasDspr2 (char uplo, int n, double alpha, const double *x, int incx, 
              const double *y, int incy, double *AP)

 performs the symmetric rank 2 operation

    A = alpha*x*transpose(y) + alpha*y*transpose(x) + A,

 where alpha is a double precision scalar, and x and y are n element double 
 precision vectors. A is a symmetric n x n matrix consisting of double 
 precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision scalar multiplier applied to x * transpose(y) + 
        y * transpose(x).
 x      double precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      double precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 AP     double precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].

 Output
 ------
 A      updated according to A = alpha*x*transpose(y)+alpha*y*transpose(x)+A

 Reference: http://www.netlib.org/blas/dspr2.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtrsv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtrsv</H3>
<PRE>
public static void <B>cublasDtrsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtrsv (char uplo, char trans, char diag, int n, const double *A, 
              int lda, double *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A or 
 transpose(A). b and x are double precision vectors consisting of n
 elements, and A is an n x n matrix composed of a unit or non-unit, upper
 or lower triangular matrix. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array containing
 A.

 No test for singularity or near-singularity is included in this function. 
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the 
        lower triangular part of array A. If uplo = 'U' or 'u', then only 
        the upper triangular part of A may be referenced. If uplo = 'L' or 
        'l', then only the lower triangular part of A may be referenced.
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If transa = 't',
        'T', 'c', or 'C', op(A) = transpose(A)
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If 
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0. 
 A      is a double precision array of dimensions (lda, n). If uplo = 'U' 
        or 'u', then A must contains the upper triangular part of a symmetric
        matrix, and the strictly lower triangular parts is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part of 
        a symmetric matrix, and the strictly upper triangular part is not 
        referenced. 
 lda    is the leading dimension of the two-dimensional array containing A.
        lda must be at least max(1, n).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the n element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/dtrsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtrmv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtrmv</H3>
<PRE>
public static void <B>cublasDtrmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtrmv (char uplo, char trans, char diag, int n, const double *A,
              int lda, double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = 
     = A, or op(A) = transpose(A). x is an n-element single precision vector, and 
 A is an n x n, unit or non-unit, upper or lower, triangular matrix composed 
 of single precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular 
        matrix. If uplo = 'U' or 'u', then A is an upper triangular matrix. 
        If uplo = 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa = 'N' or 'n', op(A) = A. If trans = 'T', 
        't', 'C', or 'c', op(A) = transpose(A)
 diag   specifies whether or not matrix A is unit triangular. If diag = 'U' 
        or 'u', A is assumed to be unit triangular. If diag = 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero.
 A      single precision array of dimension (lda, n). If uplo = 'U' or 'u', 
        the leading n x n upper triangular part of the array A must contain 
        the upper triangular matrix and the strictly lower triangular part 
        of A is not referenced. If uplo = 'L' or 'l', the leading n x n lower
        triangular part of the array A must contain the lower triangular 
        matrix and the strictly upper triangular part of A is not referenced.
        When diag = 'U' or 'u', the diagonal elements of A are not referenced
        either, but are are assumed to be unity.
 lda    is the leading dimension of A. It must be at least max (1, n).
 x      single precision array of length at least (1 + (n - 1) * abs(incx) ).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/dtrmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDgbmv(char, int, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDgbmv</H3>
<PRE>
public static void <B>cublasDgbmv</B>(char&nbsp;trans,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;kl,
                               int&nbsp;ku,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               double&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasDgbmv (char trans, int m, int n, int kl, int ku, double alpha,
              const double *A, int lda, const double *x, int incx, double beta,
              double *y, int incy);

 performs one of the matrix-vector operations

    y = alpha*op(A)*x + beta*y,  op(A)=A or op(A) = transpose(A)

 alpha and beta are double precision scalars. x and y are double precision
 vectors. A is an m by n band matrix consisting of double precision elements
 with kl sub-diagonals and ku super-diagonals.

 Input
 -----
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T', 
        't', 'C', or 'c', op(A) = transpose(A)
 m      specifies the number of rows of the matrix A. m must be at least 
        zero.
 n      specifies the number of columns of the matrix A. n must be at least
        zero.
 kl     specifies the number of sub-diagonals of matrix A. It must be at 
        least zero.
 ku     specifies the number of super-diagonals of matrix A. It must be at
        least zero.
 alpha  double precision scalar multiplier applied to op(A).
 A      double precision array of dimensions (lda, n). The leading
        (kl + ku + 1) x n part of the array A must contain the band matrix A,
        supplied column by column, with the leading diagonal of the matrix 
        in row (ku + 1) of the array, the first super-diagonal starting at 
        position 2 in row ku, the first sub-diagonal starting at position 1
        in row (ku + 2), and so on. Elements in the array A that do not 
        correspond to elements in the band matrix (such as the top left 
        ku x ku triangle) are not referenced.
 lda    leading dimension of A. lda must be at least (kl + ku + 1).
 x      double precision array of length at least (1+(n-1)*abs(incx)) when 
        trans == 'N' or 'n' and at least (1+(m-1)*abs(incx)) otherwise.
 incx   specifies the increment for the elements of x. incx must not be zero.
 beta   double precision scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      double precision array of length at least (1+(m-1)*abs(incy)) when 
        trans == 'N' or 'n' and at least (1+(n-1)*abs(incy)) otherwise. If 
        beta is zero, y is not read.
 incy   On entry, incy specifies the increment for the elements of y. incy 
        must not be zero.

 Output
 ------
 y      updated according to y = alpha*op(A)*x + beta*y

 Reference: http://www.netlib.org/blas/dgbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtbmv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtbmv</H3>
<PRE>
public static void <B>cublasDtbmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtbmv (char uplo, char trans, char diag, int n, int k, const double *A,
              int lda, double *x, int incx)

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n-element double precision vector, and A is
 an n x n, unit or non-unit, upper or lower triangular band matrix composed
 of double precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular band
        matrix. If uplo == 'U' or 'u', A is an upper triangular band matrix.
        If uplo == 'L' or 'l', A is a lower triangular band matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A)
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or 
        'u', k specifies the number of super-diagonals. If uplo == 'L' or 
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      double precision array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper 
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first 
        super-diagonal starting at position 2 in row k, and so on. The top
        left k x k triangle of the array A is not referenced. If uplo == 'L'
        or 'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first 
        sub-diagonal startingat position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 lda    is the leading dimension of A. It must be at least (k + 1).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x

 Reference: http://www.netlib.org/blas/dtbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n or k < 0, or if incx == 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtpmv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasDtpmv</H3>
<PRE>
public static void <B>cublasDtpmv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtpmv (char uplo, char trans, char diag, int n, const double *AP, 
              double *x, int incx);

 performs one of the matrix-vector operations x = op(A) * x, where op(A) = A,
 or op(A) = transpose(A). x is an n element double precision vector, and A 
 is an n x n, unit or non-unit, upper or lower triangular matrix composed 
 of double precision elements.

 Input
 -----
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo == 'U' or 'u', then A is an upper triangular matrix.
        If uplo == 'L' or 'l', then A is a lower triangular matrix.
 trans  specifies op(A). If transa == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A)
 diag   specifies whether or not matrix A is unit triangular. If diag == 'U'
        or 'u', A is assumed to be unit triangular. If diag == 'N' or 'n', A 
        is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be 
        at least zero. In the current implementation n must not exceed 4070.
 AP     double precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored in AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the source vector. On exit, x is overwritten 
        with the result vector.
 incx   specifies the storage spacing for elements of x. incx must not be 
        zero.

 Output
 ------
 x      updated according to x = op(A) * x,

 Reference: http://www.netlib.org/blas/dtpmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or n < 0
 CUBLAS_STATUS_ALLOC_FAILED     if function cannot allocate enough internal scratch vector memory 
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtpsv(char, char, char, int, Pointer, Pointer, int)"><!-- --></A><H3>
cublasDtpsv</H3>
<PRE>
public static void <B>cublasDtpsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtpsv (char uplo, char trans, char diag, int n, const double *AP, 
              double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular matrix. No test for
 singularity or near-singularity is included in this routine. Such tests 
 must be performed before calling this routine.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular matrix
        as follows: If uplo == 'U' or 'u', A is an upper triangluar matrix.
        If uplo == 'L' or 'l', A is a lower triangular matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 AP     double precision array with at least ((n*(n+1))/2) elements. If uplo
        == 'U' or 'u', the array AP contains the upper triangular matrix A,
        packed sequentially, column by column; that is, if i <= j, then 
        A[i,j] is stored is AP[i+(j*(j+1)/2)]. If uplo == 'L' or 'L', the 
        array AP contains the lower triangular matrix A, packed sequentially,
        column by column; that is, if i >= j, then A[i,j] is stored in 
        AP[i+((2*n-j+1)*j)/2]. When diag = 'U' or 'u', the diagonal elements
        of A are not referenced and are assumed to be unity.
 x      double precision array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/dtpsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0 or n > 2035
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support    
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtbsv(char, char, char, int, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtbsv</H3>
<PRE>
public static void <B>cublasDtbsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               int&nbsp;k,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void cublasDtbsv (char uplo, char trans, char diag, int n, int k,
                   const double *A, int lda, double *X, int incx)

 solves one of the systems of equations op(A)*x = b, where op(A) is either 
 op(A) = A or op(A) = transpose(A). b and x are n element vectors, and A is
 an n x n unit or non-unit, upper or lower triangular band matrix with k + 1
 diagonals. No test for singularity or near-singularity is included in this
 function. Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix is an upper or lower triangular band 
        matrix as follows: If uplo == 'U' or 'u', A is an upper triangular
        band matrix. If uplo == 'L' or 'l', A is a lower triangular band
        matrix.
 trans  specifies op(A). If trans == 'N' or 'n', op(A) = A. If trans == 'T',
        't', 'C', or 'c', op(A) = transpose(A).
 diag   specifies whether A is unit triangular. If diag == 'U' or 'u', A is
        assumed to be unit triangular; thas is, diagonal elements are not
        read and are assumed to be unity. If diag == 'N' or 'n', A is not
        assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. n must be
        at least zero.
 k      specifies the number of super- or sub-diagonals. If uplo == 'U' or
        'u', k specifies the number of super-diagonals. If uplo == 'L' or
        'l', k specifies the number of sub-diagonals. k must at least be 
        zero.
 A      double precision array of dimension (lda, n). If uplo == 'U' or 'u',
        the leading (k + 1) x n part of the array A must contain the upper
        triangular band matrix, supplied column by column, with the leading
        diagonal of the matrix in row (k + 1) of the array, the first super-
        diagonal starting at position 2 in row k, and so on. The top left 
        k x k triangle of the array A is not referenced. If uplo == 'L' or 
        'l', the leading (k + 1) x n part of the array A must constain the
        lower triangular band matrix, supplied column by column, with the
        leading diagonal of the matrix in row 1 of the array, the first
        sub-diagonal starting at position 1 in row 2, and so on. The bottom
        right k x k triangle of the array is not referenced.
 x      double precision array of length at least (1+(n-1)*abs(incx)).
 incx   storage spacing between elements of x. It must not be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/dtbsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0, n < 0 or n > 2035
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsymv(char, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDsymv</H3>
<PRE>
public static void <B>cublasDsymv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               double&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasDsymv (char uplo, int n, double alpha, const double *A, int lda, 
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y = alpha*A*x + beta*y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors, each with n elements. A is a symmetric n x n matrix 
 consisting of double precision elements that is stored in either upper or 
 lower storage mode.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the array A 
        is to be referenced. If uplo == 'U' or 'u', the symmetric matrix A 
        is stored in upper storage mode, i.e. only the upper triangular part
        of A is to be referenced while the lower triangular part of A is to 
        be inferred. If uplo == 'L' or 'l', the symmetric matrix A is stored
        in lower storage mode, i.e. only the lower triangular part of A is 
        to be referenced while the upper triangular part of A is to be 
        inferred.
 n      specifies the number of rows and the number of columns of the 
        symmetric matrix A. n must be at least zero.
 alpha  double precision scalar multiplier applied to A*x.
 A      double precision array of dimensions (lda, n). If uplo == 'U' or 'u',
        the leading n x n upper triangular part of the array A must contain
        the upper triangular part of the symmetric matrix and the strictly
        lower triangular part of A is not referenced. If uplo == 'L' or 'l',
        the leading n x n lower triangular part of the array A must contain
        the lower triangular part of the symmetric matrix and the strictly
        upper triangular part of A is not referenced. 
 lda    leading dimension of A. It must be at least max (1, n).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision scalar multiplier applied to vector y.
 y      double precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/dsymv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsbmv(char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDsbmv</H3>
<PRE>
public static void <B>cublasDsbmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               int&nbsp;k,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               double&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasDsbmv (char uplo, int n, int k, double alpha, const double *A, int lda,
              const double *x, int incx, double beta, double *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision scalars. x and y are double precision
 vectors with n elements. A is an n by n symmetric band matrix consisting 
 of double precision elements, with k super-diagonals and the same number
 of subdiagonals.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the symmetric
        band matrix A is being supplied. If uplo == 'U' or 'u', the upper 
        triangular part is being supplied. If uplo == 'L' or 'l', the lower 
        triangular part is being supplied.
 n      specifies the number of rows and the number of columns of the
        symmetric matrix A. n must be at least zero.
 k      specifies the number of super-diagonals of matrix A. Since the matrix
        is symmetric, this is also the number of sub-diagonals. k must be at
        least zero.
 alpha  double precision scalar multiplier applied to A*x.
 A      double precision array of dimensions (lda, n). When uplo == 'U' or 
        'u', the leading (k + 1) x n part of array A must contain the upper
        triangular band of the symmetric matrix, supplied column by column,
        with the leading diagonal of the matrix in row (k+1) of the array,
        the first super-diagonal starting at position 2 in row k, and so on.
        The top left k x k triangle of the array A is not referenced. When
        uplo == 'L' or 'l', the leading (k + 1) x n part of the array A must
        contain the lower triangular band part of the symmetric matrix, 
        supplied column by column, with the leading diagonal of the matrix in
        row 1 of the array, the first sub-diagonal starting at position 1 in
        row 2, and so on. The bottom right k x k triangle of the array A is
        not referenced.
 lda    leading dimension of A. lda must be at least (k + 1).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      double precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read.
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/dsbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized 
 CUBLAS_STATUS_INVALID_VALUE    if k or n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDspmv(char, int, double, Pointer, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDspmv</H3>
<PRE>
public static void <B>cublasDspmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;AP,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               double&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasDspmv (char uplo, int n, double alpha, const double *AP, const double *x,
              int incx, double beta, double *y, int incy)

 performs the matrix-vector operation
 
    y = alpha * A * x + beta * y

 Alpha and beta are double precision scalars, and x and y are double 
 precision vectors with n elements. A is a symmetric n x n matrix 
 consisting of double precision elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision scalar multiplier applied to A*x.
 AP     double precision array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the symmetric matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision scalar multiplier applied to vector y;
 y      double precision array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read. 
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to y = alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/dspmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support    
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDgemm(char, char, int, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDgemm</H3>
<PRE>
public static void <B>cublasDgemm</B>(char&nbsp;transa,
                               char&nbsp;transb,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;k,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               double&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasDgemm (char transa, char transb, int m, int n, int k, double alpha,
              const double *A, int lda, const double *B, int ldb, 
              double beta, double *C, int ldc)

 computes the product of matrix A and matrix B, multiplies the result 
 by scalar alpha, and adds the sum to the product of matrix C and
 scalar beta. It performs one of the matrix-matrix operations:

 C = alpha * op(A) * op(B) + beta * C,  
 where op(X) = X or op(X) = transpose(X),

 and alpha and beta are double-precision scalars. A, B and C are matrices
 consisting of double-precision elements, with op(A) an m x k matrix, 
 op(B) a k x n matrix, and C an m x n matrix. Matrices A, B, and C are 
 stored in column-major format, and lda, ldb, and ldc are the leading 
 dimensions of the two-dimensional arrays containing A, B, and C.

 Input
 -----
 transa specifies op(A). If transa == 'N' or 'n', op(A) = A. 
        If transa == 'T', 't', 'C', or 'c', op(A) = transpose(A).
 transb specifies op(B). If transb == 'N' or 'n', op(B) = B. 
        If transb == 'T', 't', 'C', or 'c', op(B) = transpose(B).
 m      number of rows of matrix op(A) and rows of matrix C; m must be at
        least zero.
 n      number of columns of matrix op(B) and number of columns of C; 
        n must be at least zero.
 k      number of columns of matrix op(A) and number of rows of op(B);
        k must be at least zero.
 alpha  double-precision scalar multiplier applied to op(A) * op(B).
 A      double-precision array of dimensions (lda, k) if transa == 'N' or 
        'n', and of dimensions (lda, m) otherwise. If transa == 'N' or 
        'n' lda must be at least max(1, m), otherwise lda must be at
        least max(1, k).
 lda    leading dimension of two-dimensional array used to store matrix A.
 B      double-precision array of dimensions (ldb, n) if transb == 'N' or
        'n', and of dimensions (ldb, k) otherwise. If transb == 'N' or 
        'n' ldb must be at least max (1, k), otherwise ldb must be at
        least max(1, n).
 ldb    leading dimension of two-dimensional array used to store matrix B.
 beta   double-precision scalar multiplier applied to C. If zero, C does not 
        have to be a valid input
 C      double-precision array of dimensions (ldc, n); ldc must be at least
        max(1, m).
 ldc    leading dimension of two-dimensional array used to store matrix C.
 
 Output
 ------
 C      updated based on C = alpha * op(A)*op(B) + beta * C.

 Reference: http://www.netlib.org/blas/sgemm.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS was not initialized
 CUBLAS_STATUS_INVALID_VALUE    if m < 0, n < 0, or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtrsm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtrsm</H3>
<PRE>
public static void <B>cublasDtrsm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void
 cublasDtrsm (char side, char uplo, char transa, char diag, int m, int n,
              double alpha, const double *A, int lda, double *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision scalar, and X and B are m x n matrices
 that are composed of double precision elements. A is a unit or non-unit,
 upper or lower triangular matrix, and op(A) is one of

    op(A) = A  or  op(A) = transpose(A)

 The result matrix X overwrites input matrix B; that is, on exit the result
 is stored in B. Matrices A and B are stored in column major format, and
 lda and ldb are the leading dimensions of the two-dimensonials arrays that
 contain A and B, respectively.

 Input
 -----
 side   specifies whether op(A) appears on the left or right of X as
        follows: side = 'L' or 'l' indicates solve op(A) * X = alpha * B.
        side = 'R' or 'r' indicates solve X * op(A) = alpha * B.
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix as follows: uplo = 'U' or 'u' indicates A is an upper
        triangular matrix. uplo = 'L' or 'l' indicates A is a lower
        triangular matrix.
 transa specifies the form of op(A) to be used in matrix multiplication
        as follows: If transa = 'N' or 'N', then op(A) = A. If transa =
        'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 m      specifies the number of rows of B. m must be at least zero.
 n      specifies the number of columns of B. n must be at least zero.
 alpha  is a double precision scalar to be multiplied with B. When alpha is
        zero, then A is not referenced and B need not be set before entry.
 A      is a double precision array of dimensions (lda, k), where k is
        m when side = 'L' or 'l', and is n when side = 'R' or 'r'. If
        uplo = 'U' or 'u', the leading k x k upper triangular part of
        the array A must contain the upper triangular matrix and the
        strictly lower triangular matrix of A is not referenced. When
        uplo = 'L' or 'l', the leading k x k lower triangular part of
        the array A must contain the lower triangular matrix and the
        strictly upper triangular part of A is not referenced. Note that
        when diag = 'U' or 'u', the diagonal elements of A are not
        referenced, and are assumed to be unity.
 lda    is the leading dimension of the two dimensional array containing A.
        When side = 'L' or 'l' then lda must be at least max(1, m), when
        side = 'R' or 'r' then lda must be at least max(1, n).
 B      is a double precision array of dimensions (ldb, n). ldb must be
        at least max (1,m). The leading m x n part of the array B must
        contain the right-hand side matrix B. On exit B is overwritten
        by the solution matrix X.
 ldb    is the leading dimension of the two dimensional array containing B.
        ldb must be at least max(1, m).

 Output
 ------
 B      contains the solution matrix X satisfying op(A) * X = alpha * B,
        or X * op(A) = alpha * B

 Reference: http://www.netlib.org/blas/dtrsm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtrsm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtrsm</H3>
<PRE>
public static void <B>cublasZtrsm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void
 cublasZtrsm (char side, char uplo, char transa, char diag, int m, int n,
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              cuDoubleComplex *B, int ldb)

 solves one of the matrix equations

    op(A) * X = alpha * B,   or   X * op(A) = alpha * B,

 where alpha is a double precision complex scalar, and X and B are m x n matrices
 that are composed of double precision complex elements. A is a unit or non-unit,
 upper or lower triangular matrix, and op(A) is one of

    op(A) = A  or  op(A) = transpose(A)  or  op( A ) = conj( A' ).

 The result matrix X overwrites input matrix B; that is, on exit the result
 is stored in B. Matrices A and B are stored in column major format, and
 lda and ldb are the leading dimensions of the two-dimensonials arrays that
 contain A and B, respectively.

 Input
 -----
 side   specifies whether op(A) appears on the left or right of X as
        follows: side = 'L' or 'l' indicates solve op(A) * X = alpha * B.
        side = 'R' or 'r' indicates solve X * op(A) = alpha * B.
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix as follows: uplo = 'U' or 'u' indicates A is an upper
        triangular matrix. uplo = 'L' or 'l' indicates A is a lower
        triangular matrix.
 transa specifies the form of op(A) to be used in matrix multiplication
        as follows: If transa = 'N' or 'N', then op(A) = A. If transa =
        'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 m      specifies the number of rows of B. m must be at least zero.
 n      specifies the number of columns of B. n must be at least zero.
 alpha  is a double precision complex scalar to be multiplied with B. When alpha is
        zero, then A is not referenced and B need not be set before entry.
 A      is a double precision complex array of dimensions (lda, k), where k is
        m when side = 'L' or 'l', and is n when side = 'R' or 'r'. If
        uplo = 'U' or 'u', the leading k x k upper triangular part of
        the array A must contain the upper triangular matrix and the
        strictly lower triangular matrix of A is not referenced. When
        uplo = 'L' or 'l', the leading k x k lower triangular part of
        the array A must contain the lower triangular matrix and the
        strictly upper triangular part of A is not referenced. Note that
        when diag = 'U' or 'u', the diagonal elements of A are not
        referenced, and are assumed to be unity.
 lda    is the leading dimension of the two dimensional array containing A.
        When side = 'L' or 'l' then lda must be at least max(1, m), when
        side = 'R' or 'r' then lda must be at least max(1, n).
 B      is a double precision complex array of dimensions (ldb, n). ldb must be
        at least max (1,m). The leading m x n part of the array B must
        contain the right-hand side matrix B. On exit B is overwritten
        by the solution matrix X.
 ldb    is the leading dimension of the two dimensional array containing B.
        ldb must be at least max(1, m).

 Output
 ------
 B      contains the solution matrix X satisfying op(A) * X = alpha * B,
        or X * op(A) = alpha * B

 Reference: http://www.netlib.org/blas/ztrsm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDtrmm(char, char, char, char, int, int, double, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasDtrmm</H3>
<PRE>
public static void <B>cublasDtrmm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void 
 cublasDtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              double alpha, const double *A, int lda, const double *B, int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision scalar, B is an m x n matrix composed
 of double precision elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision elements. op(A) is one of

   op(A) = A  or  op(A) = transpose(A)

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.

 Input
 -----
 side   specifies whether op(A) multiplies B from the left or right.
        If side = 'L' or 'l', then B = alpha * op(A) * B. If side =
        'R' or 'r', then B = alpha * B * op(A).
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo = 'U' or 'u', A is an upper triangular matrix.
        If uplo = 'L' or 'l', A is a lower triangular matrix.
 transa specifies the form of op(A) to be used in the matrix 
        multiplication. If transa = 'N' or 'n', then op(A) = A. If
        transa = 'T', 't', 'C', or 'c', then op(A) = transpose(A).
 diag   specifies whether or not A is unit triangular. If diag = 'U'
        or 'u', A is assumed to be unit triangular. If diag = 'N' or
        'n', A is not assumed to be unit triangular.
 m      the number of rows of matrix B. m must be at least zero.
 n      the number of columns of matrix B. n must be at least zero.
 alpha  double precision scalar multiplier applied to op(A)*B, or
        B*op(A), respectively. If alpha is zero no accesses are made
        to matrix A, and no read accesses are made to matrix B.
 A      double precision array of dimensions (lda, k). k = m if side =
        'L' or 'l', k = n if side = 'R' or 'r'. If uplo = 'U' or 'u'
        the leading k x k upper triangular part of the array A must
        contain the upper triangular matrix, and the strictly lower
        triangular part of A is not referenced. If uplo = 'L' or 'l'
        the leading k x k lower triangular part of the array A must
        contain the lower triangular matrix, and the strictly upper
        triangular part of A is not referenced. When diag = 'U' or 'u'
        the diagonal elements of A are no referenced and are assumed
        to be unity.
 lda    leading dimension of A. When side = 'L' or 'l', it must be at
        least max(1,m) and at least max(1,n) otherwise
 B      double precision array of dimensions (ldb, n). On entry, the 
        leading m x n part of the array contains the matrix B. It is
        overwritten with the transformed matrix on exit.
 ldb    leading dimension of B. It must be at least max (1, m).

 Output
 ------
 B      updated according to B = alpha * op(A) * B  or B = alpha * B * op(A)

 Reference: http://www.netlib.org/blas/dtrmm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsymm(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDsymm</H3>
<PRE>
public static void <B>cublasDsymm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               double&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void
 cublasDsymm (char side, char uplo, int m, int n, double alpha,
              const double *A, int lda, const double *B, int ldb,
              double beta, double *C, int ldc);

 performs one of the matrix-matrix operations

   C = alpha * A * B + beta * C, or
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision scalars, A is a symmetric matrix
 consisting of double precision elements and stored in either lower or upper
 storage mode, and B and C are m x n matrices consisting of double precision
 elements.

 Input
 -----
 side   specifies whether the symmetric matrix A appears on the left side
        hand side or right hand side of matrix B, as follows. If side == 'L'
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r',
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the symmetric matrix A is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper
        triangular part of the symmetric matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the
        lower triangular part of the symmetric matrix is to be referenced,
        and the elements of the strictly upper triangular part are to be
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of symmetric matrix A
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of
        columns of matrix B. It also specifies the dimensions of symmetric
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  double precision scalar multiplier applied to A * B, or B * A
 A      double precision array of dimensions (lda, ka), where ka is m when
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the
        leading m x m part of array A must contain the symmetric matrix,
        such that when uplo == 'U' or 'u', the leading m x m part stores the
        upper triangular part of the symmetric matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u',
        the leading m x m part stores the lower triangular part of the
        symmetric matrix and the strictly upper triangular part is not
        referenced. If side == 'R' or 'r' the leading n x n part of array A
        must contain the symmetric matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the
        symmetric matrix and the strictly lower triangular part of A is not
        referenced, and when uplo == 'U' or 'u', the leading n x n part
        stores the lower triangular part of the symmetric matrix and the
        strictly upper triangular part is not referenced.
 lda    leading dimension of A. When side == 'L' or 'l', it must be at least
        max(1, m) and at least max(1, n) otherwise.
 B      double precision array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   double precision scalar multiplier applied to C. If beta is zero, C
        does not have to be a valid input
 C      double precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha *
        B * A + beta * C

 Reference: http://www.netlib.org/blas/dsymm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZsymm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZsymm</H3>
<PRE>
public static void <B>cublasZsymm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZsymm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a symmetric matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.

 Input
 -----
 side   specifies whether the symmetric matrix A appears on the left side 
        hand side or right hand side of matrix B, as follows. If side == 'L' 
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r', 
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the symmetric matrix A is stored in upper or lower 
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of symmetric matrix A 
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of 
        columns of matrix B. It also specifies the dimensions of symmetric 
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  double precision scalar multiplier applied to A * B, or B * A
 A      double precision array of dimensions (lda, ka), where ka is m when 
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the 
        leading m x m part of array A must contain the symmetric matrix, 
        such that when uplo == 'U' or 'u', the leading m x m part stores the 
        upper triangular part of the symmetric matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u', 
        the leading m x m part stores the lower triangular part of the 
        symmetric matrix and the strictly upper triangular part is not 
        referenced. If side == 'R' or 'r' the leading n x n part of array A 
        must contain the symmetric matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the 
        symmetric matrix and the strictly lower triangular part of A is not 
        referenced, and when uplo == 'U' or 'u', the leading n x n part 
        stores the lower triangular part of the symmetric matrix and the 
        strictly upper triangular part is not referenced.
 lda    leading dimension of A. When side == 'L' or 'l', it must be at least 
        max(1, m) and at least max(1, n) otherwise.
 B      double precision array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   double precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input
 C      double precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha * 
        B * A + beta * C

 Reference: http://www.netlib.org/blas/zsymm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsyrk(char, char, int, int, double, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDsyrk</H3>
<PRE>
public static void <B>cublasDsyrk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               double&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasDsyrk (char uplo, char trans, int n, int k, double alpha, 
              const double *A, int lda, double beta, double *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.

 Alpha and beta are double precision scalars. C is an n x n symmetric matrix 
 consisting of double precision elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of double precision elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * transpose(A) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = transpose(A) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  double precision scalar multiplier applied to A * transpose(A) or 
        transpose(A) * A.
 A      double precision array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   double precision scalar multiplier applied to C. If beta izs zero, C
        does not have to be a valid input
 C      double precision array of dimensions (ldc, n). If uplo = 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo = 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * transpose(A) + beta * C, or C = 
        alpha * transpose(A) * A + beta * C

 Reference: http://www.netlib.org/blas/dsyrk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZsyrk(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZsyrk</H3>
<PRE>
public static void <B>cublasZsyrk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZsyrk (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank k operations
 
   C = alpha * A * transpose(A) + beta * C, or 
   C = alpha * transpose(A) * A + beta * C.

 Alpha and beta are double precision complex scalars. C is an n x n symmetric matrix 
 consisting of double precision complex elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of double precision complex elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * transpose(A) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = transpose(A) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  double precision complex scalar multiplier applied to A * transpose(A) or 
        transpose(A) * A.
 A      double precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   double precision complex scalar multiplier applied to C. If beta izs zero, C
        does not have to be a valid input
 C      double precision complex array of dimensions (ldc, n). If uplo = 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo = 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * transpose(A) + beta * C, or C = 
        alpha * transpose(A) * A + beta * C

 Reference: http://www.netlib.org/blas/zsyrk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZsyr2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZsyr2k</H3>
<PRE>
public static void <B>cublasZsyr2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZsyr2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               cuDoubleComplex beta, cuDoubleComplex *C, int ldc)

 performs one of the symmetric rank 2k operations
 
    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or 
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.

 Alpha and beta are double precision complex scalars. C is an n x n symmetric matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode. A and B are matrices consisting of double precision complex elements 
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the symmetric matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the symmetric matrix is to be references, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', 
        C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, 
        If trans == 'T', 't', 'C', or 'c', C = alpha * transpose(A) * B + 
        alpha * transpose(B) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  double precision scalar multiplier.
 A      double precision array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at 
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      double precision array of dimensions (lda, kb), where kb is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array B must contain the matrix B, 
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   double precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      double precision array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the symmetric matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*transpose(B) + alpha*B*transpose(A) + 
        beta*C or alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C

 Reference:   http://www.netlib.org/blas/zsyr2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZher2k(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasZher2k</H3>
<PRE>
public static void <B>cublasZher2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                double&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZher2k (char uplo, char trans, int n, int k, cuDoubleComplex alpha, 
               const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
               double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank 2k operations
 
    C =   alpha * A * conjugate(transpose(B)) 
        + conjugate(alpha) * B * conjugate(transpose(A))  
        + beta * C , 
    or 
    C =  alpha * conjugate(transpose(A)) * B 
       + conjugate(alpha) * conjugate(transpose(B)) * A 
       + beta * C.

 Alpha is double precision complex scalar whereas Beta is a double precision real scalar.
 C is an n x n hermitian matrix consisting of double precision complex elements and 
 stored in either lower or upper storage mode. A and B are matrices consisting of 
 double precision complex elements with dimension of n x k in the first case, 
 and k x n in the second case.

 Input
 -----
 uplo   specifies whether the hermitian matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be references, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', 
        C =   alpha * A * conjugate(transpose(B)) 
            + conjugate(alpha) * B * conjugate(transpose(A))  
            + beta * C .
        If trans == 'T', 't', 'C', or 'c',
        C =  alpha * conjugate(transpose(A)) * B 
          + conjugate(alpha) * conjugate(transpose(B)) * A 
          + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  double precision scalar multiplier.
 A      double precision array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at 
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      double precision array of dimensions (lda, kb), where kb is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array B must contain the matrix B, 
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   double precision scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input.
 C      double precision array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the hermitian matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo == 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the hermitian matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
        The imaginary parts of the diagonal elements need
        not be set,  they are assumed to be zero,  and on exit they
        are set to zero. 
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*conjugate(transpose(B)) + 
        + conjugate(alpha)*B*conjugate(transpose(A)) + beta*C or
        alpha*conjugate(transpose(A))*B + conjugate(alpha)*conjugate(transpose(B))*A
        + beta*C.

 Reference:   http://www.netlib.org/blas/zher2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZher(char, int, double, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZher</H3>
<PRE>
public static void <B>cublasZher</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              double&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;A,
                              int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void 
 cublasZher (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *A, int lda)

 performs the hermitian rank 1 operation

    A = alpha * x * conjugate(transpose(x)) + A,

 where alpha is a double precision real scalar, x is an n element double 
 precision complex vector and A is an n x n hermitian matrix consisting of 
 double precision complex elements. Matrix A is stored in column major format,
 and lda is the leading dimension of the two-dimensional array 
 containing A.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or 
        the lower triangular part of array A. If uplo = 'U' or 'u',
        then only the upper triangular part of A may be referenced.
        If uplo = 'L' or 'l', then only the lower triangular part of
        A may be referenced.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0.
 alpha  double precision real scalar multiplier applied to 
        x * conjugate(transpose(x))
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must 
        not be zero.
 A      double precision complex array of dimensions (lda, n). If uplo = 'U' or 
        'u', then A must contain the upper triangular part of a hermitian 
        matrix, and the strictly lower triangular part is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part 
        of a hermitian matrix, and the strictly upper triangular part is 
        not referenced. The imaginary parts of the diagonal elements need
        not be set, they are assumed to be zero, and on exit they
        are set to zero. 
 lda    leading dimension of the two-dimensional array containing A. lda
        must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(x)) + A

 Reference: http://www.netlib.org/blas/zher.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhpr(char, int, double, Pointer, int, Pointer)"><!-- --></A><H3>
cublasZhpr</H3>
<PRE>
public static void <B>cublasZhpr</B>(char&nbsp;uplo,
                              int&nbsp;n,
                              double&nbsp;alpha,
                              Pointer&nbsp;x,
                              int&nbsp;incx,
                              Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre>
 void 
 cublasZhpr (char uplo, int n, double alpha, const cuDoubleComplex *x, int incx, 
             cuDoubleComplex *AP)

 performs the hermitian rank 1 operation
 
    A = alpha * x * conjugate(transpose(x)) + A,
 
 where alpha is a double precision real scalar and x is an n element double 
 precision complex vector. A is a hermitian n x n matrix consisting of double 
 precision complex elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array AP. If uplo == 'U' or 'u', then the upper 
        triangular part of A is supplied in AP. If uplo == 'L' or 'l', then 
        the lower triangular part of A is supplied in AP.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision real scalar multiplier applied to x * conjugate(transpose(x)).
 x      double precision array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 AP     double precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
        The imaginary parts of the diagonal elements need not be set, they
        are assumed to be zero, and on exit they are set to zero. 

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(x)) + A

 Reference: http://www.netlib.org/blas/zhpr.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, or incx == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhpr2(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer)"><!-- --></A><H3>
cublasZhpr2</H3>
<PRE>
public static void <B>cublasZhpr2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;AP)</PRE>
<DL>
<DD><pre> 
 void 
 cublasZhpr2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
              const cuDoubleComplex *y, int incy, cuDoubleComplex *AP)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, and x and y are n element double 
 precision complex vectors. A is a hermitian n x n matrix consisting of double 
 precision complex elements that is supplied in packed form.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision complex scalar multiplier applied to x * conjugate(transpose(y)) + 
        y * conjugate(transpose(x)).
 x      double precision complex array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      double precision complex array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 AP     double precision complex array with at least ((n * (n + 1)) / 2) elements. If
        uplo == 'U' or 'u', the array AP contains the upper triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i <= j, then A[i,j] is stored is AP[i+(j*(j+1)/2)]. If 
        uplo == 'L' or 'L', the array AP contains the lower triangular part 
        of the hermitian matrix A, packed sequentially, column by column; 
        that is, if i >= j, then A[i,j] is stored in AP[i+((2*n-j+1)*j)/2].
        The imaginary parts of the diagonal elements need not be set, they
        are assumed to be zero, and on exit they are set to zero.  

 Output
 ------
 A      updated according to A = alpha*x*conjugate(transpose(y))
                               + conjugate(alpha)*y*conjugate(transpose(x))+A

 Reference: http://www.netlib.org/blas/zhpr2.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZher2(char, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZher2</H3>
<PRE>
public static void <B>cublasZher2</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 void cublasZher2 (char uplo, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
                   const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the hermitian rank 2 operation

    A = alpha*x*conjugate(transpose(y)) + conjugate(alpha)*y*conjugate(transpose(x)) + A,

 where alpha is a double precision complex scalar, x and y are n element double 
 precision complex vector and A is an n by n hermitian matrix consisting of double 
 precision complex elements.
 
 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the lower
        triangular part of array A. If uplo == 'U' or 'u', then only the 
        upper triangular part of A may be referenced and the lower triangular
        part of A is inferred. If uplo == 'L' or 'l', then only the lower 
        triangular part of A may be referenced and the upper triangular part
        of A is inferred.
 n      specifies the number of rows and columns of the matrix A. It must be
        at least zero.
 alpha  double precision complex scalar multiplier applied to x * conjugate(transpose(y)) + 
        y * conjugate(transpose(x)).
 x      double precision array of length at least (1 + (n - 1) * abs (incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 y      double precision array of length at least (1 + (n - 1) * abs (incy)).
 incy   storage spacing between elements of y. incy must not be zero.
 A      double precision complex array of dimensions (lda, n). If uplo == 'U' or 'u',
        then A must contains the upper triangular part of a hermitian matrix,
        and the strictly lower triangular parts is not referenced. If uplo ==
        'L' or 'l', then A contains the lower triangular part of a hermitian 
        matrix, and the strictly upper triangular part is not referenced.
        The imaginary parts of the diagonal elements need not be set, 
        they are assumed to be zero, and on exit they are set to zero. 

 lda    leading dimension of A. It must be at least max(1, n).

 Output
 ------
 A      updated according to A = alpha*x*conjugate(transpose(y))
                               + conjugate(alpha)*y*conjugate(transpose(x))+A

 Reference: http://www.netlib.org/blas/zher2.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support  
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasDsyr2k(char, char, int, int, double, Pointer, int, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasDsyr2k</H3>
<PRE>
public static void <B>cublasDsyr2k</B>(char&nbsp;uplo,
                                char&nbsp;trans,
                                int&nbsp;n,
                                int&nbsp;k,
                                double&nbsp;alpha,
                                Pointer&nbsp;A,
                                int&nbsp;lda,
                                Pointer&nbsp;B,
                                int&nbsp;ldb,
                                double&nbsp;beta,
                                Pointer&nbsp;C,
                                int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void
 cublasDsyr2k (char uplo, char trans, int n, int k, double alpha,
               const double *A, int lda, const double *B, int ldb,
               double beta, double *C, int ldc)

 performs one of the symmetric rank 2k operations

    C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C, or
    C = alpha * transpose(A) * B + alpha * transpose(B) * A + beta * C.

 Alpha and beta are double precision scalars. C is an n x n symmetric matrix
 consisting of double precision elements and stored in either lower or upper
 storage mode. A and B are matrices consisting of double precision elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the symmetric matrix C is stored in upper or lower
        storage mode, as follows. If uplo == 'U' or 'u', only the upper
        triangular part of the symmetric matrix is to be referenced, and the
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the
        lower triangular part of the symmetric matrix is to be references,
        and the elements of the strictly upper triangular part are to be
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n',
        C = alpha * A * transpose(B) + alpha * B * transpose(A) + beta * C,
        If trans == 'T', 't', 'C', or 'c', C = alpha * transpose(A) * B +
        alpha * transpose(B) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A.
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of rows of matrix A.
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of
        matrix A. k must be at least zero.
 alpha  double precision scalar multiplier.
 A      double precision array of dimensions (lda, ka), where ka is k when
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n',
        the leading n x k part of array A must contain the matrix A,
        otherwise the leading k x n part of the array must contain the matrix
        A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1,k).
 B      double precision array of dimensions (lda, kb), where kb is k when
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n',
        the leading n x k part of array B must contain the matrix B,
        otherwise the leading k x n part of the array must contain the matrix
        B.
 ldb    leading dimension of N. When trans == 'N' or 'n' then ldb must be at
        least max(1, n). Otherwise ldb must be at least max(1, k).
 beta   double precision scalar multiplier applied to C. If beta is zero, C
        does not have to be a valid input.
 C      double precision array of dimensions (ldc, n). If uplo == 'U' or 'u',
        the leading n x n triangular part of the array C must contain the
        upper triangular part of the symmetric matrix C and the strictly
        lower triangular part of C is not referenced. On exit, the upper
        triangular part of C is overwritten by the upper triangular part of
        the updated matrix. If uplo == 'L' or 'l', the leading n x n
        triangular part of the array C must contain the lower triangular part
        of the symmetric matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is
        overwritten by the lower triangular part of the updated matrix.
 ldc    leading dimension of C. Must be at least max(1, n).

 Output
 ------
 C      updated according to alpha*A*transpose(B) + alpha*B*transpose(A) +
        beta*C or alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C

 Reference:   http://www.netlib.org/blas/dsyr2k.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZgemm(char, char, int, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZgemm</H3>
<PRE>
public static void <B>cublasZgemm</B>(char&nbsp;transa,
                               char&nbsp;transb,
                               int&nbsp;m,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void cublasZgemm (char transa, char transb, int m, int n, int k,
                   cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
                   const cuDoubleComplex *B, int ldb, cuDoubleComplex beta,
                   cuDoubleComplex *C, int ldc)

 zgemm performs one of the matrix-matrix operations

    C = alpha * op(A) * op(B) + beta*C,

 where op(X) is one of

    op(X) = X   or   op(X) = transpose  or  op(X) = conjg(transpose(X))

 alpha and beta are double-complex scalars, and A, B and C are matrices
 consisting of double-complex elements, with op(A) an m x k matrix, op(B)
 a k x n matrix and C an m x n matrix.

 Input
 -----
 transa specifies op(A). If transa == 'N' or 'n', op(A) = A. If transa ==
        'T' or 't', op(A) = transpose(A). If transa == 'C' or 'c', op(A) =
        conjg(transpose(A)).
 transb specifies op(B). If transa == 'N' or 'n', op(B) = B. If transb ==
        'T' or 't', op(B) = transpose(B). If transb == 'C' or 'c', op(B) =
        conjg(transpose(B)).
 m      number of rows of matrix op(A) and rows of matrix C. It must be at
        least zero.
 n      number of columns of matrix op(B) and number of columns of C. It
        must be at least zero.
 k      number of columns of matrix op(A) and number of rows of op(B). It
        must be at least zero.
 alpha  double-complex scalar multiplier applied to op(A)op(B)
 A      double-complex array of dimensions (lda, k) if transa ==  'N' or
        'n'), and of dimensions (lda, m) otherwise.
 lda    leading dimension of A. When transa == 'N' or 'n', it must be at
        least max(1, m) and at least max(1, k) otherwise.
 B      double-complex array of dimensions (ldb, n) if transb == 'N' or 'n',
        and of dimensions (ldb, k) otherwise
 ldb    leading dimension of B. When transb == 'N' or 'n', it must be at
        least max(1, k) and at least max(1, n) otherwise.
 beta   double-complex scalar multiplier applied to C. If beta is zero, C
        does not have to be a valid input.
 C      double precision array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m).

 Output
 ------
 C      updated according to C = alpha*op(A)*op(B) + beta*C

 Reference: http://www.netlib.org/blas/zgemm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if any of m, n, or k are < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtrmm(char, char, char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtrmm</H3>
<PRE>
public static void <B>cublasZtrmm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               char&nbsp;transa,
                               char&nbsp;diag,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtrmm (char side, char uplo, char transa, char diag, int m, int n, 
              cuDoubleComplex alpha, const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, 
              int ldb)

 performs one of the matrix-matrix operations

   B = alpha * op(A) * B,  or  B = alpha * B * op(A)

 where alpha is a double-precision complex scalar, B is an m x n matrix composed
 of double precision complex elements, and A is a unit or non-unit, upper or lower, 
 triangular matrix composed of double precision complex elements. op(A) is one of

   op(A) = A  , op(A) = transpose(A) or op(A) = conjugate(transpose(A))

 Matrices A and B are stored in column major format, and lda and ldb are 
 the leading dimensions of the two-dimensonials arrays that contain A and 
 B, respectively.

 Input
 -----
 side   specifies whether op(A) multiplies B from the left or right.
        If side = 'L' or 'l', then B = alpha * op(A) * B. If side =
        'R' or 'r', then B = alpha * B * op(A).
 uplo   specifies whether the matrix A is an upper or lower triangular
        matrix. If uplo = 'U' or 'u', A is an upper triangular matrix.
        If uplo = 'L' or 'l', A is a lower triangular matrix.
 transa specifies the form of op(A) to be used in the matrix 
        multiplication. If transa = 'N' or 'n', then op(A) = A. If
        transa = 'T' or 't', then op(A) = transpose(A).
        If transa = 'C' or 'c', then op(A) = conjugate(transpose(A)).
 diag   specifies whether or not A is unit triangular. If diag = 'U'
        or 'u', A is assumed to be unit triangular. If diag = 'N' or
        'n', A is not assumed to be unit triangular.
 m      the number of rows of matrix B. m must be at least zero.
 n      the number of columns of matrix B. n must be at least zero.
 alpha  double precision complex scalar multiplier applied to op(A)*B, or
        B*op(A), respectively. If alpha is zero no accesses are made
        to matrix A, and no read accesses are made to matrix B.
 A      double precision complex array of dimensions (lda, k). k = m if side =
        'L' or 'l', k = n if side = 'R' or 'r'. If uplo = 'U' or 'u'
        the leading k x k upper triangular part of the array A must
        contain the upper triangular matrix, and the strictly lower
        triangular part of A is not referenced. If uplo = 'L' or 'l'
        the leading k x k lower triangular part of the array A must
        contain the lower triangular matrix, and the strictly upper
        triangular part of A is not referenced. When diag = 'U' or 'u'
        the diagonal elements of A are no referenced and are assumed
        to be unity.
 lda    leading dimension of A. When side = 'L' or 'l', it must be at
        least max(1,m) and at least max(1,n) otherwise
 B      double precision complex array of dimensions (ldb, n). On entry, the 
        leading m x n part of the array contains the matrix B. It is
        overwritten with the transformed matrix on exit.
 ldb    leading dimension of B. It must be at least max (1, m).

 Output
 ------
 B      updated according to B = alpha * op(A) * B  or B = alpha * B * op(A)

 Reference: http://www.netlib.org/blas/ztrmm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZgeru(int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZgeru</H3>
<PRE>
public static void <B>cublasZgeru</B>(int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasZgeru (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * transpose(y) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.
 
 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least 
        zero.
 n      specifies the number of columns of the matrix A. It must be at 
        least zero.
 alpha  double precision complex scalar multiplier applied to x * transpose(y)
 x      double precision complex array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      double precision complex array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not 
        be zero.
 A      double precision complex array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * transpose(y) + A

 Reference: http://www.netlib.org/blas/zgeru.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m < 0, n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZgerc(int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZgerc</H3>
<PRE>
public static void <B>cublasZgerc</B>(int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               Pointer&nbsp;y,
                               int&nbsp;incy,
                               Pointer&nbsp;A,
                               int&nbsp;lda)</PRE>
<DL>
<DD><pre>
 cublasZgerc (int m, int n, cuDoubleComplex alpha, const cuDoubleComplex *x, int incx, 
             const cuDoubleComplex *y, int incy, cuDoubleComplex *A, int lda)

 performs the symmetric rank 1 operation

    A = alpha * x * conjugate(transpose(y)) + A,

 where alpha is a double precision complex scalar, x is an m element double 
 precision complex vector, y is an n element double precision complex vector, and A 
 is an m by n matrix consisting of double precision complex elements. Matrix A
 is stored in column major format, and lda is the leading dimension of
 the two-dimensional array used to store A.
 
 Input
 -----
 m      specifies the number of rows of the matrix A. It must be at least 
        zero.
 n      specifies the number of columns of the matrix A. It must be at 
        least zero.
 alpha  double precision complex scalar multiplier applied to x * conjugate(transpose(y))
 x      double precision array of length at least (1 + (m - 1) * abs(incx))
 incx   specifies the storage spacing between elements of x. incx must not
        be zero.
 y      double precision complex array of length at least (1 + (n - 1) * abs(incy))
 incy   specifies the storage spacing between elements of y. incy must not 
        be zero.
 A      double precision complex array of dimensions (lda, n).
 lda    leading dimension of two-dimensional array used to store matrix A

 Output
 ------
 A      updated according to A = alpha * x * conjugate(transpose(y)) + A

 Reference: http://www.netlib.org/blas/zgerc.f

 Error status for this function can be retrieved via cublasGetError().
 
 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m < 0, n < 0, incx == 0, incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZherk(char, char, int, int, double, Pointer, int, double, Pointer, int)"><!-- --></A><H3>
cublasZherk</H3>
<PRE>
public static void <B>cublasZherk</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               int&nbsp;n,
                               int&nbsp;k,
                               double&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               double&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZherk (char uplo, char trans, int n, int k, double alpha, 
              const cuDoubleComplex *A, int lda, double beta, cuDoubleComplex *C, int ldc)

 performs one of the hermitian rank k operations
 
   C = alpha * A * conjugate(transpose(A)) + beta * C, or 
   C = alpha * conjugate(transpose(A)) * A + beta * C.

 Alpha and beta are double precision scalars. C is an n x n hermitian matrix 
 consisting of double precision complex elements and stored in either lower or 
 upper storage mode. A is a matrix consisting of double precision complex elements
 with dimension of n x k in the first case, and k x n in the second case.

 Input
 -----
 uplo   specifies whether the hermitian matrix C is stored in upper or lower 
        storage mode as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 trans  specifies the operation to be performed. If trans == 'N' or 'n', C = 
        alpha * A * conjugate(transpose(A)) + beta * C. If trans == 'T', 't', 'C', or 'c', 
        C = alpha * conjugate(transpose(A)) * A + beta * C.
 n      specifies the number of rows and the number columns of matrix C. If 
        trans == 'N' or 'n', n specifies the number of rows of matrix A. If 
        trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A. 
        n must be at least zero.
 k      If trans == 'N' or 'n', k specifies the number of columns of matrix A. 
        If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of 
        matrix A. k must be at least zero.
 alpha  double precision scalar multiplier applied to A * conjugate(transpose(A)) or 
        conjugate(transpose(A)) * A.
 A      double precision complex array of dimensions (lda, ka), where ka is k when 
        trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n', 
        the leading n x k part of array A must contain the matrix A, 
        otherwise the leading k x n part of the array must contains the 
        matrix A.
 lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
        least max(1, n). Otherwise lda must be at least max(1, k).
 beta   double precision scalar multiplier applied to C. If beta is zero, C
        does not have to be a valid input
 C      double precision complex array of dimensions (ldc, n). If uplo = 'U' or 'u',
        the leading n x n triangular part of the array C must contain the 
        upper triangular part of the hermitian matrix C and the strictly 
        lower triangular part of C is not referenced. On exit, the upper 
        triangular part of C is overwritten by the upper triangular part of 
        the updated matrix. If uplo = 'L' or 'l', the leading n x n 
        triangular part of the array C must contain the lower triangular part
        of the hermitian matrix C and the strictly upper triangular part of C
        is not referenced. On exit, the lower triangular part of C is 
        overwritten by the lower triangular part of the updated matrix.
        The imaginary parts of the diagonal elements need
        not be set,  they are assumed to be zero,  and on exit they
        are set to zero.
 ldc    leading dimension of C. It must be at least max(1, n).

 Output
 ------
 C      updated according to C = alpha * A * conjugate(transpose(A)) + beta * C, or C = 
        alpha * conjugate(transpose(A)) * A + beta * C

 Reference: http://www.netlib.org/blas/zherk.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhemm(char, char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZhemm</H3>
<PRE>
public static void <B>cublasZhemm</B>(char&nbsp;side,
                               char&nbsp;uplo,
                               int&nbsp;m,
                               int&nbsp;n,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;B,
                               int&nbsp;ldb,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;C,
                               int&nbsp;ldc)</PRE>
<DL>
<DD><pre>
 void 
 cublasZhemm (char side, char uplo, int m, int n, cuDoubleComplex alpha, 
              const cuDoubleComplex *A, int lda, const cuDoubleComplex *B, int ldb, 
              cuDoubleComplex beta, cuDoubleComplex *C, int ldc);

 performs one of the matrix-matrix operations
 
   C = alpha * A * B + beta * C, or 
   C = alpha * B * A + beta * C,

 where alpha and beta are double precision complex scalars, A is a hermitian matrix
 consisting of double precision complex elements and stored in either lower or upper 
 storage mode, and B and C are m x n matrices consisting of double precision
 complex elements.

 Input
 -----
 side   specifies whether the hermitian matrix A appears on the left side 
        hand side or right hand side of matrix B, as follows. If side == 'L' 
        or 'l', then C = alpha * A * B + beta * C. If side = 'R' or 'r', 
        then C = alpha * B * A + beta * C.
 uplo   specifies whether the hermitian matrix A is stored in upper or lower 
        storage mode, as follows. If uplo == 'U' or 'u', only the upper 
        triangular part of the hermitian matrix is to be referenced, and the 
        elements of the strictly lower triangular part are to be infered from
        those in the upper triangular part. If uplo == 'L' or 'l', only the 
        lower triangular part of the hermitian matrix is to be referenced, 
        and the elements of the strictly upper triangular part are to be 
        infered from those in the lower triangular part.
 m      specifies the number of rows of the matrix C, and the number of rows
        of matrix B. It also specifies the dimensions of hermitian matrix A 
        when side == 'L' or 'l'. m must be at least zero.
 n      specifies the number of columns of the matrix C, and the number of 
        columns of matrix B. It also specifies the dimensions of hermitian 
        matrix A when side == 'R' or 'r'. n must be at least zero.
 alpha  double precision scalar multiplier applied to A * B, or B * A
 A      double precision complex array of dimensions (lda, ka), where ka is m when 
        side == 'L' or 'l' and is n otherwise. If side == 'L' or 'l' the 
        leading m x m part of array A must contain the hermitian matrix, 
        such that when uplo == 'U' or 'u', the leading m x m part stores the 
        upper triangular part of the hermitian matrix, and the strictly lower
        triangular part of A is not referenced, and when uplo == 'U' or 'u', 
        the leading m x m part stores the lower triangular part of the 
        hermitian matrix and the strictly upper triangular part is not 
        referenced. If side == 'R' or 'r' the leading n x n part of array A 
        must contain the hermitian matrix, such that when uplo == 'U' or 'u',
        the leading n x n part stores the upper triangular part of the 
        hermitian matrix and the strictly lower triangular part of A is not 
        referenced, and when uplo == 'U' or 'u', the leading n x n part 
        stores the lower triangular part of the hermitian matrix and the 
        strictly upper triangular part is not referenced. The imaginary parts
        of the diagonal elements need not be set, they are assumed to be zero.

 lda    leading dimension of A. When side == 'L' or 'l', it must be at least 
        max(1, m) and at least max(1, n) otherwise.
 B      double precision complex array of dimensions (ldb, n). On entry, the leading
        m x n part of the array contains the matrix B.
 ldb    leading dimension of B. It must be at least max (1, m).
 beta   double precision complex scalar multiplier applied to C. If beta is zero, C 
        does not have to be a valid input
 C      double precision complex array of dimensions (ldc, n)
 ldc    leading dimension of C. Must be at least max(1, m)

 Output
 ------
 C      updated according to C = alpha * A * B + beta * C, or C = alpha * 
        B * A + beta * C

 Reference: http://www.netlib.org/blas/zhemm.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if m or n are < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZtrsv(char, char, char, int, Pointer, int, Pointer, int)"><!-- --></A><H3>
cublasZtrsv</H3>
<PRE>
public static void <B>cublasZtrsv</B>(char&nbsp;uplo,
                               char&nbsp;trans,
                               char&nbsp;diag,
                               int&nbsp;n,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx)</PRE>
<DL>
<DD><pre>
 void 
 cublasZtrsv (char uplo, char trans, char diag, int n, const cuDoubleComplex *A, 
              int lda, cuDoubleComplex *x, int incx)

 solves a system of equations op(A) * x = b, where op(A) is either A,  
 transpose(A) or conjugate(transpose(A)). b and x are double precision 
 complex vectors consisting of n elements, and A is an n x n matrix 
 composed of a unit or non-unit, upper or lower triangular matrix.
 Matrix A is stored in column major format, and lda is the leading 
 dimension of the two-dimensional array containing A.

 No test for singularity or near-singularity is included in this function. 
 Such tests must be performed before calling this function.

 Input
 -----
 uplo   specifies whether the matrix data is stored in the upper or the 
        lower triangular part of array A. If uplo = 'U' or 'u', then only 
        the upper triangular part of A may be referenced. If uplo = 'L' or 
        'l', then only the lower triangular part of A may be referenced.
 trans  specifies op(A). If transa = 'n' or 'N', op(A) = A. If transa = 't',
        'T', 'c', or 'C', op(A) = transpose(A)
 diag   specifies whether or not A is a unit triangular matrix like so:
        if diag = 'U' or 'u', A is assumed to be unit triangular. If 
        diag = 'N' or 'n', then A is not assumed to be unit triangular.
 n      specifies the number of rows and columns of the matrix A. It
        must be at least 0. 
 A      is a double precision complex array of dimensions (lda, n). If uplo = 'U' 
        or 'u', then A must contains the upper triangular part of a symmetric
        matrix, and the strictly lower triangular parts is not referenced. 
        If uplo = 'L' or 'l', then A contains the lower triangular part of 
        a symmetric matrix, and the strictly upper triangular part is not 
        referenced. 
 lda    is the leading dimension of the two-dimensional array containing A.
        lda must be at least max(1, n).
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
        On entry, x contains the n element right-hand side vector b. On exit,
        it is overwritten with the solution vector x.
 incx   specifies the storage spacing between elements of x. incx must not 
        be zero.

 Output
 ------
 x      updated to contain the solution vector x that solves op(A) * x = b.

 Reference: http://www.netlib.org/blas/ztrsv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
 CUBLAS_STATUS_INVALID_VALUE    if incx == 0 or if n < 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support 
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cublasZhbmv(char, int, int, jcuda.jcublas.cuDoubleComplex, Pointer, int, Pointer, int, jcuda.jcublas.cuDoubleComplex, Pointer, int)"><!-- --></A><H3>
cublasZhbmv</H3>
<PRE>
public static void <B>cublasZhbmv</B>(char&nbsp;uplo,
                               int&nbsp;n,
                               int&nbsp;k,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;alpha,
                               Pointer&nbsp;A,
                               int&nbsp;lda,
                               Pointer&nbsp;x,
                               int&nbsp;incx,
                               <A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas">cuDoubleComplex</A>&nbsp;beta,
                               Pointer&nbsp;y,
                               int&nbsp;incy)</PRE>
<DL>
<DD><pre>
 void 
 cublasZhbmv (char uplo, int n, int k, cuDoubleComplex alpha, const cuDoubleComplex *A, int lda,
              const cuDoubleComplex *x, int incx, cuDoubleComplex beta, cuDoubleComplex *y, int incy)

 performs the matrix-vector operation

     y := alpha*A*x + beta*y

 alpha and beta are double precision complex scalars. x and y are double precision
 complex vectors with n elements. A is an n by n hermitian band matrix consisting 
 of double precision complex elements, with k super-diagonals and the same number
 of subdiagonals.

 Input
 -----
 uplo   specifies whether the upper or lower triangular part of the hermitian
        band matrix A is being supplied. If uplo == 'U' or 'u', the upper 
        triangular part is being supplied. If uplo == 'L' or 'l', the lower 
        triangular part is being supplied.
 n      specifies the number of rows and the number of columns of the
        hermitian matrix A. n must be at least zero.
 k      specifies the number of super-diagonals of matrix A. Since the matrix
        is hermitian, this is also the number of sub-diagonals. k must be at
        least zero.
 alpha  double precision complex scalar multiplier applied to A*x.
 A      double precision complex array of dimensions (lda, n). When uplo == 'U' or 
        'u', the leading (k + 1) x n part of array A must contain the upper
        triangular band of the hermitian matrix, supplied column by column,
        with the leading diagonal of the matrix in row (k+1) of the array,
        the first super-diagonal starting at position 2 in row k, and so on.
        The top left k x k triangle of the array A is not referenced. When
        uplo == 'L' or 'l', the leading (k + 1) x n part of the array A must
        contain the lower triangular band part of the hermitian matrix, 
        supplied column by column, with the leading diagonal of the matrix in
        row 1 of the array, the first sub-diagonal starting at position 1 in
        row 2, and so on. The bottom right k x k triangle of the array A is
        not referenced. The imaginary parts of the diagonal elements need 
        not be set, they are assumed to be zero. 
 lda    leading dimension of A. lda must be at least (k + 1).
 x      double precision complex array of length at least (1 + (n - 1) * abs(incx)).
 incx   storage spacing between elements of x. incx must not be zero.
 beta   double precision complex scalar multiplier applied to vector y. If beta is 
        zero, y is not read.
 y      double precision complex array of length at least (1 + (n - 1) * abs(incy)). 
        If beta is zero, y is not read.
 incy   storage spacing between elements of y. incy must not be zero.

 Output
 ------
 y      updated according to alpha*A*x + beta*y

 Reference: http://www.netlib.org/blas/zhbmv.f

 Error status for this function can be retrieved via cublasGetError().

 Error Status
 ------------
 CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized 
 CUBLAS_STATUS_INVALID_VALUE    if k or n < 0, or if incx or incy == 0
 CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support   
 CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../jcuda/jcublas/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCublas.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/jcublas/cuDoubleComplex.html" title="class in jcuda.jcublas"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/jcublas/JCublas.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCublas.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
